<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Toast的一些坑]]></title>
    <url>%2F2019%2F01%2F20%2FAndroid%20Toast%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html</url>
    <content type="text"><![CDATA[Toast是Android系统中最常用的提示，但是在开发中碰到过几次棘手的问题。 1. 莫名其妙的闪退12android.view.WindowManager$BadTokenExceptionis your activity running? 在Android 7版本都有这个问题，当我看到这个问题的时候，我想好解决，是不是Activity销毁了导致的，所以在Toast show的时候判断Activity是否销毁，发现线上还会有闪退，too young！！ 然后继续想办法，将Application当做Context 传入，想着应该解决了吧，然而发现问题继续存在。 只能查看源码了，为什么在Android 7版本上有问题，对比了不同版本的源码发现Android 8版本上加上了try catch判断，那怎么解决这个问题呢？ 方案一：hook context getWindowManager 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final class SafeToastContext extends ContextWrapper &#123; private @NonNull Toast toast; SafeToastContext(@NonNull Context base, @NonNull Toast toast) &#123; super(base); this.toast = toast; &#125; @Override public Context getApplicationContext() &#123; return new ApplicationContextWrapper(getBaseContext().getApplicationContext()); &#125; private final class ApplicationContextWrapper extends ContextWrapper &#123; private ApplicationContextWrapper(@NonNull Context base) &#123; super(base); &#125; @Override public Object getSystemService(@NonNull String name) &#123; if (Context.WINDOW_SERVICE.equals(name)) &#123; // noinspection ConstantConditions return new WindowManagerWrapper((WindowManager) getBaseContext().getSystemService(name)); &#125; return super.getSystemService(name); &#125; &#125; private final class WindowManagerWrapper implements WindowManager &#123; private static final String TAG = "WindowManagerWrapper"; private final @NonNull WindowManager base; private WindowManagerWrapper(@NonNull WindowManager base) &#123; this.base = base; &#125; @Override public void addView(View view, ViewGroup.LayoutParams params) &#123; try &#123; Log.d(TAG, "WindowManager's addView(view, params) has been hooked."); base.addView(view, params); &#125; catch (BadTokenException e) &#123; Log.i(TAG, e.getMessage()); &#125; catch (Throwable throwable) &#123; Log.e(TAG, "[addView]", throwable); &#125; &#125; &#125;&#125; 改完后发布线上，发现完美，没有闪退。可以开心睡觉了！ 高兴的太早，线上用户反馈部分机型Toast无法弹出，最终发现在一些机型上的确无法弹出，部分Rom修改了一些逻辑，加入了Context的一些判断逻辑。 继续战斗，将只有Android 7上才Hook Context，减少影响范围，线上用户并没有反馈Android 7 Toast弹不出来的问题，问题终于解决。但作为一个完美的程序员，考虑虽然减少范围只hook Android 7 ，万一部分Android 7机型弹不出Toast怎么办。 方案二：继续阅读源码，找找可以解决问题的方法，发现可以hook toast Handler handlerShow方法，这样就不会影响Context，最终测试，发现完美，可以加个鸡腿了。 1234567891011121314151617181920212223class SafelyHandlerWrapper extends Handler &#123; private Handler impl; public SafelyHandlerWrapper(Handler impl) &#123; this.impl = impl; &#125; public void dispatchMessage(Message msg) &#123; try &#123; this.impl.dispatchMessage(msg); &#125; catch (Exception var3) &#123; ; &#125; &#125; public void handleMessage(Message msg) &#123; try &#123; this.impl.handleMessage(msg); &#125; catch (Exception var3) &#123; ; &#125; &#125;&#125; 虽然解决了这个问题，但是具体什么导致的一直没找到原因，也一直未能复现，后来参考一些资料解释： 这个问题由于targetSDKVersion升到26之后，在7.1.1机型上概率性出现。稳定复现的步骤是，在Toast.show()之后，UI线程做了耗时的操作阻塞了Handler message的处理，如使用Thread.sleep(5000)，然后这个崩溃就出现了。原因是7.1.1系统对TYPE_TOAST的Window类型做了超时限制，绑定了Window Token，最长超时时间是3.5s，如果UI在这段时间内没有执行完，Toast.show()内部的handler message得不到执行，NotificationManageService那端会把这个Toast取消掉，同时把Toast对于的window token置为无效。等App端真正需要显示Toast时，因为window token已经失效，ViewRootImpl就抛出了上面的异常。 2. 当通知栏权限被禁掉Toast无法弹出发现在Android 6版本及以上，通知栏权限被禁止了Toast无法弹出，这个逻辑我真不值得google是怎么想的，那我们App中的提示该怎么办呢？ 可参考Toast源码，自定义一个提示，通过window manger addview显示， 首先Params.type=Toast类型，发现通知权限被禁掉以后，使用Toast类型会出异常。发现Params.type不设置的时候，可以弹出自定义View。 后面有部分用户反馈Toast还是无法弹出，检查发现部分机型Context不是Activity的时候，不设置Params.type是无法显示的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 private void addWindowToast(Context context, Toast toast) &#123; // We can resolve the Gravity here by using the Locale for getting // the layout direction WindowManager.LayoutParams mParams = new WindowManager.LayoutParams(); mParams.height = WindowManager.LayoutParams.WRAP_CONTENT; mParams.width = WindowManager.LayoutParams.WRAP_CONTENT; mParams.format = PixelFormat.TRANSLUCENT; mParams.windowAnimations = R.style.ToastAnimation; // 为什么不能加 TYPE_TOAST，因为通知权限在关闭后设置显示的类型为Toast会报错 // android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?// mParams.type = WindowManager.LayoutParams.TYPE_TOAST; // 判断是否为 Android 6.0 及以上系统并且有悬浮窗权限 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O &amp;&amp; Settings.canDrawOverlays(context)) &#123; mParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY; &#125; else if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M &amp;&amp; Settings.canDrawOverlays(context))&#123; mParams.type = WindowManager.LayoutParams.TYPE_PHONE; &#125; mParams.setTitle("Toast"); mParams.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; final int gravity = toast.getGravity(); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = toast.getXOffset(); mParams.y = toast.getYOffset(); mParams.verticalMargin = toast.getVerticalMargin(); mParams.horizontalMargin = toast.getHorizontalMargin(); mParams.packageName = context.getPackageName(); try &#123; mWM.addView(toast.getView(), mParams); &#125; catch (WindowManager.BadTokenException e) &#123; /* ignore */ Log.d(TAG, "addWindowToast: " + e.getMessage()); &#125; catch (Exception e1) &#123; //ignore Log.d(TAG, "addWindowToast: " + e1.getMessage()); &#125; catch (Error error) &#123; //ignore &#125; mHandler.postDelayed(this, toast.getDuration() == Toast.LENGTH_LONG ? 4000 : 2000); &#125; 继续思考解决方法，主动初始化调用application.registerActivityLifecycleCallbacks，缓存Activity， 使用顶部Activity弹出自定义Toast，在Activity销毁移除Toast，通过这个方案可以完美解决上述问题。 解决这个问题后还有问题，当App没有Activity的时候，在Service中还是存在无法弹出问题，所以可以添加悬浮窗权限，在通知权限禁掉的时候主动申请悬浮窗权限，使用Params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY来解决这个问题， 但是用户有的不一定同意悬浮窗权限，所以还是存在可能Toast无法弹出的问题。 最终也只做到这一步，只是尽量做的更好，没有完美的解决这个问题。 Github]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeakCanary源码解析]]></title>
    <url>%2F2018%2F04%2F25%2FLeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[LeakCanary是square公司发布的一款检测Activity内存泄漏的工具。项目地址 1 设计1.1 类图 1.2 时序图 2.核心类功能介绍2.1 LeakCanary.javaLeakCanary主要是一个工具类，构建RefWatcher对象。(1)主要函数123public static RefWatcher install(Application application);public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result, boolean detailed); 第一个方法主要是初始化安装LeakCanary模块，还包括一些舒适化参数的构建。第二个方法是通过最后分析的Dump文件和结果构建输入字符串。这个方法后面在Activity上显示会使用到。 2.2 RefWatcherBuilder.java这个类主要是构建RefWatcher的包装类，它有个子类ActivityRefWatcher包含一些对Android的适配, 具体方法这里忽略，可以看下面RefWatcher包含成员变量。 2.3 ActivityRefWatcher.java这个类主要是创建App ActivityLifecycleCallbacks监听Activity destory事件，然后调用RefWatcher分析回收问题。(1)主要函数123456789101112public void watchActivities() &#123; // Make sure you don't get installed twice. stopWatchingActivities(); application.registerActivityLifecycleCallbacks(lifecycleCallbacks);&#125;public void stopWatchingActivities() &#123; application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);&#125;void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity);&#125; 可以看到主要是通过application.registerActivityLifecycleCallbacks的方式监听Activity生命周期，然后调用refWatcher.watch(activity) 2.4 RefWatcher.java这个类是核心类，主要分析Activity是否被回收和生成Dump文件。(1)主要成员12345678private final WatchExecutor watchExecutor;private final DebuggerControl debuggerControl;private final GcTrigger gcTrigger;private final HeapDumper heapDumper;private final Set&lt;String&gt; retainedKeys;private final ReferenceQueue&lt;Object&gt; queue;private final HeapDump.Listener heapdumpListener;private final ExcludedRefs excludedRefs; watchExecutor：执行回收和dump文件处理的线程提供者。子类有AndroidWatchExecutor其实就是在子线程中处理。debuggerControl: 主要判断当前APP是否以Debug模式运行。gcTrigger：调用GC方法heapDumper：生成内存快照文件retainedKeys： 存放key值，每个key对应一个Activity的虚引用。queue： 负责存放虚引用对象释放完的队列。heapdumpListener： 处理Dump信息excludedRefs： 忽略一个内存泄漏的方法。(2)主要方法1234567891011121314151617181920212223242526272829Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; ... removeWeaklyReachableReferences(); if (debuggerControl.isDebuggerAttached()) &#123; // The debugger can create false leaks. return RETRY; &#125; if (gone(reference)) &#123; return DONE; &#125; gcTrigger.runGc(); removeWeaklyReachableReferences(); if (!gone(reference)) &#123; long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) &#123; // Could not dump the heap. return RETRY; &#125; long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); heapdumpListener.analyze( new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); &#125; return DONE; &#125; 这个涉及到Java中虚引用的概念，可google详细了解。首先直接判断Activity是否释放，如果释放直接结束，没有的话就调用系统GC，再判断Activity是否释放，如果释放直接结束，没有的话生成DumpFile，然后交给HeapdumpListener处理。 2.5 HeapAnalyzerService.java解析DumpFile文件的后台服务 2.6 HeapAnalyzer.java解析DumpFile文件工具类(1)主要方法1public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey)； 解析过程较为复杂，有兴趣的可以了解下。主要是解析Hprof文件，GCRoots. 2.7 AnalysisResult.java保存分析结果的存储对象。(1)主要成员1234567public final boolean leakFound;public final boolean excludedLeak;public final String className;public final LeakTrace leakTrace;public final Throwable failure;public final long retainedHeapSize;public final long analysisDurationMs; 2.8 DisplayLeakService.java主要负责通知栏提醒和保存分析结果。 2.9 其他其他模块主要是对结果进行展示的逻辑，这里就不一一分析。 3 杂谈1.这里是通过手动触发GC，然后判断回收，手动触发GC会打乱系统自动回收，影响APP性能，所以注意不要发布到正式包。2.那需要思考的正式环境想统计内存泄漏问题怎么办？自己有个思路但是有缺陷（1）开启一个线程阻塞ReferenceQueue.remove(), 然后定时（5分钟）去读取retainedKeys中的未被回收的Activity。（2）但是Android系统回收无规律和没有事件通知，不知道系统到底是否已经触发回收。]]></content>
  </entry>
  <entry>
    <title><![CDATA[VA加载插件资源]]></title>
    <url>%2F2017%2F09%2F13%2FVA%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6%E8%B5%84%E6%BA%90.html</url>
    <content type="text"><![CDATA[解决插件资源生效问题，首先需要看看系统创建资源 1.资源创建流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384private ContextImpl(ContextImpl container, ActivityThread mainThread, LoadedApk packageInfo, ...) &#123; //... //省略了部分源码 Resources resources = packageInfo.getResources(mainThread); mResources = resources; //... //省略了部分源码&#125;public Resources getResources() &#123; return mResources;&#125;``` 继续跟进```javapublic final class LoadedApk &#123; private final String mResDir; public LoadedApk(ActivityThread activityThread, ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, boolean securityViolation, boolean includeCode, boolean registerPackage) &#123; final int myUid = Process.myUid(); aInfo = adjustNativeLibraryPaths(aInfo); mActivityThread = activityThread; mApplicationInfo = aInfo; mPackageName = aInfo.packageName; mAppDir = aInfo.sourceDir; mResDir = aInfo.uid == myUid ? aInfo.sourceDir : aInfo.publicSourceDir; // 注意一下这个sourceDir，这个是我们宿主的APK包在手机中的路径，宿主的资源通过此地址加载。 // 该值的生成涉及到PMS,暂时不进行分析。 // Full path to the base APK for this application. //.... &#125;//.... public Resources getResources(ActivityThread mainThread) &#123; if (mResources == null) &#123; mResources = mainThread.getTopLevelResources(mResDir, mSplitResDirs, mOverlayDirs, mApplicationInfo.sharedLibraryFiles, Display.DEFAULT_DISPLAY, null, this); &#125; return mResources; &#125;//....&#125;``` ```javapublic final class ActivityThread &#123; Resources getTopLevelResources(String resDir, CompatibilityInfo compInfo) &#123; //我们暂时只关注下面这一段代码 AssetManager assets = new AssetManager(); if (assets.addAssetPath(resDir) == 0) &#123; //此处将上面的mResDir，也就是宿主的APK在手机中的路径当做资源包添加到AssetManager里，则Resources对象可以通过AssetManager查找资源，此处见(老罗博客：Android应用程序资源的查找过程分析) return null; &#125; // 创建Resources对象，此处依赖AssetManager类来实现资源查找功能。 r = new Resources(assets, metrics, getConfiguration(), compInfo); &#125; &#125;``` 2. 上面分析完Resources的创建流程，现在继续看如何使加载插件资源```javaprivate static Resources createResources(Context context, File apk) &#123; if (Constants.COMBINE_RESOURCES) &#123; //如果插件资源合并到宿主里面去的情况，插件可以访问宿主的资源 Resources resources = new ResourcesManager().createResources(context, apk.getAbsolutePath()); ResourcesManager.hookResources(context, resources); return resources; &#125; else &#123; //插件使用独立的Resources，不与宿主有关系，无法访问到宿主的资源 Resources hostResources = context.getResources(); AssetManager assetManager = createAssetManager(context, apk); return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration()); &#125;&#125; （1）如果是独立的资源， 只需要重新创建新的资源，不用管宿主资源（2）如果是插件资源需要使用宿主资源，就需要添加宿主资源和所有的插件资源 12345678910111213141516171819202122232425262728293031323334353637class ResourcesManager &#123; public static synchronized Resources createResources(Context hostContext, String apk) &#123; Resources hostResources = hostContext.getResources(); Resources newResources = null; AssetManager assetManager; try &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; assetManager = AssetManager.class.newInstance(); ReflectUtil.invoke(AssetManager.class, assetManager, "addAssetPath", hostContext.getApplicationInfo().sourceDir); &#125; else &#123; assetManager = hostResources.getAssets(); &#125; ReflectUtil.invoke(AssetManager.class, assetManager, "addAssetPath", apk); List&lt;LoadedPlugin&gt; pluginList = PluginManager.getInstance(hostContext).getAllLoadedPlugins(); for (LoadedPlugin plugin : pluginList) &#123; ReflectUtil.invoke(AssetManager.class, assetManager, "addAssetPath", plugin.getLocation()); &#125; if (isMiUi(hostResources)) &#123; newResources = MiUiResourcesCompat.createResources(hostResources, assetManager); &#125; else if (isVivo(hostResources)) &#123; newResources = VivoResourcesCompat.createResources(hostContext, hostResources, assetManager); &#125; else if (isNubia(hostResources)) &#123; newResources = NubiaResourcesCompat.createResources(hostResources, assetManager); &#125; else if (isNotRawResources(hostResources)) &#123; newResources = AdaptationResourcesCompat.createResources(hostResources, assetManager); &#125; else &#123; // is raw android resources newResources = new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return newResources; &#125; （1）这里针对21一下版本和21以上版本做了区分，问题在于21以下版本在addPath之前，AssetManager中的资源路径已经初始化,再次获取的时候将不会改变。（2）这里还有个疑问，针对api21以上，AssetManager使用的同一个引用，为什么需要每次重新添加之前的所有插件资源？像官方提过问题，一直没回复。 1234567891011121314151617const ResTable* AssetManager::getResTable(bool required) const&#123; ResTable* rt = mResources; if (rt) &#123; return rt; &#125; // Iterate through all asset packages, collecting resources from each. AutoMutex _l(mLock); if (mResources != NULL) &#123; return mResources; &#125; //下面是为null的时候重新全部初始化addPath进来的文件资源&#125; mResources指向的是一个ResTable对象，如果它的值不等于NULL，那么就说明当前应用程序已经解析过它使用的资源包里面的resources.arsc文件，因此，这时候AssetManager类的成员函数getResources就可以直接将该ResTable对象返回给调用者。如果还没有初始化 mResources 则按照一定步骤遍历当前应用所使用的每个资源包进而生成 mResources 。 所以在 Android L 之前是需要想办法构造一个新的AssetManager里的 mResources 才行，这里有两种方案，VirtualAPK 用的是类似 InstantRun 的那种方案，构造一个新的AssetManager，将宿主和加载过的插件的所有 apk 全都添加一遍，然后再调用hookResources方法将新的 Resources 替换回原来的，这样会引起两个问题，一个是每次加载新的插件都会重新构造一个 AssetManger 和 Resources，然后重新添加所有资源，这样涉及到很多机型的兼容(因为部分厂商自己修改了 Resources 的类名)，一个是需要有一个替换原来Resources的过程，这样就需要涉及到很多地方，从hookResources的实现里看，替换了四处地方，在尽量少的 hook 原则下这样的情况还是尽量避免的。另外还有一种方案，可以看下VirtualAPK 资源篇 回到上面createResources， 解决完AssetManager的问题然后创建Resources， 然后针对国产手机做兼容性处理 3.使资源生效，通俗点就是替换Context中的Resource 123456789101112131415161718192021222324252627@Overridepublic Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; try &#123; cl.loadClass(className); &#125; catch (ClassNotFoundException e) &#123; LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent); String targetClassName = PluginUtil.getTargetActivity(intent); Log.i(TAG, String.format("newActivity[%s : %s]", className, targetClassName)); if (targetClassName != null) &#123; Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent); activity.setIntent(intent); try &#123; // for 4.1+ ReflectUtil.setField(ContextThemeWrapper.class, activity, "mResources", plugin.getResources());//注意此处的代码 &#125; catch (Exception ignored) &#123; // ignored. &#125; return activity; &#125; &#125; return mBase.newActivity(cl, className, intent);&#125; 这部分的处理在很多插件框架中都有存在，也就是之前对于21版本以下。这里对资源做了一次赋值的缘由需要探讨一下。跟踪到新建Activity对象的地方，也就是出现问题的地方,这里通过4.4的代码解释一下，后面版本的代码虽然变化大但也会出现问题，追溯到底的原因是一样的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;//..... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to instantiate activity " + component + ": " + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, "Performing launch of " + r); if (localLOGV) Slog.v( TAG, r + ": app=" + app + ", appName=" + app.getPackageName() + ", pkg=" + r.packageInfo.getPackageName() + ", comp=" + r.intent.getComponent().toShortString() + ", dir=" + r.packageInfo.getAppDir()); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity);//出现问题的地点 CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; mInstrumentation.callActivityOnCreate(activity, r.state);//此处调用了onCreate方法，如果不进行资源处理则在此出现找不到资源的crash if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; mInstrumentation.callActivityOnPostCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onPostCreate()"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to start activity " + component + ": " + e.toString(), e); &#125; &#125; return activity; &#125; private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; ContextImpl appContext = new ContextImpl(); appContext.init(r.packageInfo, r.token, this); appContext.setOuterContext(activity); // For debugging purposes, if the activity's package name contains the value of // the "debug.use-second-display" system property as a substring, then show // its content on a secondary display if there is one. Context baseContext = appContext; return baseContext; &#125;``` 系统在创建完Activity对象后，紧接着创建Activity所附着的Context，从最上面的创建Resources 一部分内容可知，在createBaseContextForActivity 方法中创建出来的ContextImpl appContext 使用的是宿主的Resources，如果不进行处理紧接着Activity会走入onCreate的生命周期中，此时插件加载资源的时候还是使用的宿主的资源，而不是我们特意为插件所创建出来的Resources对象，则会发生找不到资源的问题，这里用了一个很机智的方式解决这个问题。 @Override```java public Resources getResources() &#123; if (mResources != null) &#123;//我们提前设置了mResources 所以不会走到下面去 return mResources; &#125; if (mOverrideConfiguration == null) &#123; mResources = super.getResources(); return mResources; &#125; else &#123; Context resc = createConfigurationContext(mOverrideConfiguration); mResources = resc.getResources(); return mResources; &#125; &#125; 其实在于Resource中是通过AssetManager获取资源的，对于Api21以下，每次添加插件资源的时候都会创建一个新的AssetManager，而且保存在一个新的Resource中。在API21以上，AssetManager使用的是同一个引用，在添加插件资源的时候，是往同一个AssetManager中添加，所以并不会有这个问题。 4.Service中的资源处理LocalService.onStartCommand(Intent intent, int flags, int startId)中(为什么在这里后面分析四大组件的时候会讲) 12345678 Application app = plugin.getApplication();IBinder token = appThread.asBinder();Method attach = service.getClass().getMethod("attach", Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);IActivityManager am = mPluginManager.getActivityManager(); IActivityManager am = mPluginManager.getActivityManager(); attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am); 这里将之前创建插件Context放置到Service中，下面继续看看插件Context的创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class PluginContext extends ContextWrapper &#123; private final LoadedPlugin mPlugin; public PluginContext(LoadedPlugin plugin) &#123; super(plugin.getPluginManager().getHostContext()); this.mPlugin = plugin; &#125; @Override public Context getApplicationContext() &#123; return this.mPlugin.getApplication(); &#125; @Override public ApplicationInfo getApplicationInfo() &#123; return this.mPlugin.getApplicationInfo(); &#125; private Context getHostContext() &#123; return getBaseContext(); &#125; @Override public ContentResolver getContentResolver() &#123; return new PluginContentResolver(getHostContext()); &#125; @Override public ClassLoader getClassLoader() &#123; return this.mPlugin.getClassLoader(); &#125; @Override public String getPackageName() &#123; return this.mPlugin.getPackageName(); &#125; @Override public String getPackageResourcePath() &#123; return this.mPlugin.getPackageResourcePath(); &#125; @Override public String getPackageCodePath() &#123; return this.mPlugin.getCodePath(); &#125; @Override public PackageManager getPackageManager() &#123; return this.mPlugin.getPackageManager(); &#125; @Override public Object getSystemService(String name) &#123; // intercept CLIPBOARD_SERVICE,NOTIFICATION_SERVICE if (name.equals(Context.CLIPBOARD_SERVICE)) &#123; return getHostContext().getSystemService(name); &#125; else if (name.equals(Context.NOTIFICATION_SERVICE)) &#123; return getHostContext().getSystemService(name); &#125; return super.getSystemService(name); &#125; @Override public Resources getResources() &#123; return this.mPlugin.getResources(); &#125; @Override public AssetManager getAssets() &#123; return this.mPlugin.getAssets(); &#125; @Override public Resources.Theme getTheme() &#123; return this.mPlugin.getTheme(); &#125; @Override public void startActivity(Intent intent) &#123; ComponentsHandler componentsHandler = mPlugin.getPluginManager().getComponentsHandler(); componentsHandler.transformIntentToExplicitAsNeeded(intent); super.startActivity(intent); &#125;&#125; 其实就是创建了一个代理Context， 获取的资源等其他都是从插件Resource中获取。 5.BroadcastReceiver这一点比较奇怪，BroadcastReceiver中的资源并未替换，那在Api24以下是否存在问题，这个我已经向官方反馈。 12345678910111213141516171819202122232425262728293031323334Map&lt;ComponentName, ActivityInfo&gt; receivers = new HashMap&lt;ComponentName, ActivityInfo&gt;();for (PackageParser.Activity receiver : this.mPackage.receivers) &#123; receivers.put(receiver.getComponentName(), receiver.info); try &#123; BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance()); for (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123; this.mHostContext.registerReceiver(br, aii); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;//改成下面这样 应该就没问题Map&lt;ComponentName, ActivityInfo&gt; receivers = new HashMap&lt;ComponentName, ActivityInfo&gt;();for (PackageParser.Activity receiver : this.mPackage.receivers) &#123; receivers.put(receiver.getComponentName(), receiver.info); try &#123; final BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance()); BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; br.onReceive(getPluginContext(), intent); &#125; &#125;; for (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123; this.mHostContext.registerReceiver(broadcastReceiver, aii); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>插件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualAPK插件化简介和学习计划]]></title>
    <url>%2F2017%2F09%2F12%2FVirtualAPK%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92.html</url>
    <content type="text"><![CDATA[VirtualAPK(下面简称VA)是滴滴开源的插件化项目，这里有VirtualAPK的详细介绍。插件化方面也一直没有大公司开源， DroidPlugin虽然功能强大，但是hook的东西比较多，而且宿主和插件互相独立，和平时的业务需求有较多差异。VirtualAPK介绍中也有几个开源库之前的简单对比。 如下是VirtualAPK和主流的插件化框架之间的对比。 插件化需要解决的问题： 1. 加载插件资源插件资源问题插件重名冲突问题 参考资料VirtualAPK 资源篇 2. Dex加载3. 插件中四大组件不在宿主中注册如何生效的问题。ActivityServiceBroadcastContentProvider]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>插件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016总结]]></title>
    <url>%2F2016%2F12%2F31%2F2016%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[2016总结 2016、2016、 不知不觉就过去了。给自己打个分应该是负分吧， 不满意。 上半年和之前的同事在融资困难的情况下艰苦创业了半年，期间感觉状态不太好，在我没有什么提高，在这期间，为了能保持自己的code状态，独立完成了独立完成了微博第三方客户端，已经上线，并完成版本的迭代 下载地址。9月份入职新公司，主要做视频直播，主要的市场在北美，前两个月熟悉项目的代码，完成通用组件的开发和优化。后面两个月完成项目2.0迭代，基本独立完成聊天模块的内容，期间有点感冒，挺累的，好在元旦前正式上线，还是很赞。 今年主要的几件事是内推腾讯面试，当时没有准备，最后挂在了算法上，后面恶补了算法，把java常用的数据结构源码分析了一遍；收到了facefook的邀请面试，这个让我兴奋了好一阵子，虽然最后我放弃了（英语太渣☺）；坚持了三个月的跑步，这个状态比较好；github粉丝破百了，哈哈。 看了去年的目标，大部分已经完成，自己对自己的提升度不太满意。2017的计划现在很迷茫，准备深入的学习下后台，把之前的博客整理下。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit搭配Rx实践]]></title>
    <url>%2F2016%2F09%2F28%2FRetrofit%E6%90%AD%E9%85%8DRx%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[最近在重构公司的网络层，准备使用最近比较火的组合，采用Retrofit搭配Rx，下面是基础部分一些实践和心得。 1. 初始化1234567Retrofit retrofit = new Retrofit.Builder() .baseUrl(NetWorkManager.BASE_URL) .addConverterFactory(LiveStarConverterFactory.create(GsonUtils.getGson())) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .callFactory(createOkHttpClient()) .build();sLiveStarApi = retrofit.create(LiveStarApi.class); 配置基本的url、数据解析和数据请求方式。 2.添加通用参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 static OkHttpClient createOkHttpClient() &#123; return OkHttpClientProvider.getDefaultOkHttpClient() //这里是默认的client 包括请求超时， 调试抓包 .newBuilder() .addInterceptor(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); request = interceptRequest(request); return chain.proceed(request); &#125; &#125;) .build();&#125;static Request interceptRequest(Request request) &#123; RequestBody requestBody = request.body(); if (requestBody == null) &#123; //get &#125;else if (requestBody instanceof FormBody) &#123; FormBody formBody = (FormBody) requestBody; Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); for (int i = 0; i &lt; formBody.size(); i ++) &#123; String name = formBody.name(i); String value = formBody.value(i); params.put(name, value); &#125; appendRequestBody(params); formBody = generateRequestBody(params); request = request.newBuilder().post(formBody).build(); &#125;else if (requestBody instanceof MultipartBody) &#123; MultipartBody multipartBody = (MultipartBody) requestBody; MultipartBody.Builder builder = new MultipartBody.Builder(); builder.setType(multipartBody.type()); long time = System.currentTimeMillis() / 1000; String flag = MD5Util.getStringMD5(Contant.USER_IMG_UPLOAD_KEY + time); builder.addFormDataPart("time", String.valueOf(time)); builder.addFormDataPart("flag", flag); for (MultipartBody.Part part : multipartBody.parts()) &#123; builder.addPart(part); &#125; request = request.newBuilder().post(builder.build()).build(); &#125; return request;&#125; 这里就是通过okhttp的拦截器添加通用参数。 因为涉及到具体业务， 所以不详细贴代码。 3.创建基础Response类12345678910111213141516171819202122232425262728293031323334public class LiveStarResponse &#123; private int code; private String message; private boolean state; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public boolean isState() &#123; return state; &#125; public void setState(boolean state) &#123; this.state = state; &#125; public boolean isSuccessful() &#123; return code == ResponseCode.SUCCESS &amp;&amp; state; &#125;&#125; 4. 返回错误处理123456789101112131415161718192021public class ErrorCheckerTransformer&lt;T extends LiveStarResponse&gt; implements Observable.Transformer&lt;T, T&gt; &#123; @Override public Observable&lt;T&gt; call(Observable&lt;T&gt; observable) &#123; return observable.map(new Func1&lt;T, T&gt;() &#123; @Override public T call(T t) &#123; if (!t.isSuccessful()) &#123; throw new RuntimeException(new ErrorResponseException(t)); &#125; else &#123; return t; &#125; &#125; &#125;); &#125; public static &lt;T extends LiveStarResponse&gt; ErrorCheckerTransformer&lt;T&gt; create() &#123; return new ErrorCheckerTransformer&lt;&gt;(); &#125;&#125; 5. 配置线程123456789101112public class SchedulerTransformer&lt;T&gt; implements Observable.Transformer&lt;T, T&gt; &#123; @Override public Observable&lt;T&gt; call(Observable&lt;T&gt; observable) &#123; return observable .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); &#125; public static &lt;T&gt; SchedulerTransformer&lt;T&gt; create() &#123; return new SchedulerTransformer&lt;&gt;(); &#125;&#125; 6. 创建返回错误统一处理方案12345678910111213141516171819202122232425262728293031323334public abstract class DefaultResponseSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; &#123; private BaseView mBaseView; public DefaultResponseSubscriber(BaseView baseView) &#123; mBaseView = baseView; &#125; public void onError(Throwable e) &#123; String hint; if (e instanceof IOException) &#123; // network is bad hint = App.getContext().getString(R.string.no_netwrok_hint); &#125;else if (e instanceof HttpException)&#123; //这里是http code 不是200 HttpException httpException = (HttpException) e; hint = "Http Exception" + httpException.code() + " " + httpException.message(); &#125;else if (e instanceof RuntimeException &amp;&amp; e.getCause() instanceof ErrorResponseException) &#123; //这个是服务器返回的数据 不是200 ErrorResponseException errorResponseException = (ErrorResponseException) e.getCause(); if (errorResponseException.getResponse().getCode() == 309) &#123; //token失效。 mBaseView.onAuthError(); return; &#125;else &#123; hint = errorResponseException.getResponse().getMessage(); &#125; &#125;else &#123; hint = e.getMessage(); &#125; onFail(e, hint); &#125; protected abstract void onFail(Throwable e, String hint);&#125; 7. 开始请求12345678910111213141516171819202122232425262728293031323334mCashOutManager.cashOutSwitch() .compose(ErrorCheckerTransformer.&lt;CheckCashOutResponse&gt;create()) .compose(SchedulerTransformer.&lt;CheckCashOutResponse&gt;create()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; mCashOutView.showLoading(true); &#125; &#125;).doOnTerminate(new Action0() &#123; @Override public void call() &#123; mCashOutView.showLoading(false); &#125; &#125;).subscribe(new DefaultResponseSubscriber&lt;CheckCashOutResponse&gt;(mCashOutView) &#123; @Override protected void onFail(Throwable e, String hint) &#123; mCashOutView.onError(hint); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onNext(CheckCashOutResponse response) &#123; if (response.isSuccessful() &amp;&amp; response.getData() != null &amp;&amp; !TextUtils.isEmpty(response.getData().getUrl())) &#123; mCashOutView.onCashOutCheckSuccess(response); &#125;else &#123; mCashOutView.onCashOutCheckError(App.getContext().getString(R.string.star_money_tip)); &#125; &#125; &#125;); 8. 遇到的一些坑在涉及到MultipartBody的时候GosnConverterFactory默认是MediaType.parse(“application/json; charset=UTF-8”)，其实并不是json的格式，会导致请求失败问题。所以我采用自定义RequestBodyConverter对改变基本类型MediaType12345678910111213141516171819202122232425final class RequestBodyConverter&lt;T&gt; implements Converter&lt;T, RequestBody&gt; &#123; private static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json; charset=UTF-8"); private static final Charset UTF_8 = Charset.forName("UTF-8"); private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; RequestBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123; this.gson = gson; this.adapter = adapter; &#125; @Override public RequestBody convert(T value) throws IOException &#123; if (value instanceof String || value instanceof Long || value instanceof Integer) &#123; return RequestBody.create(null, String.valueOf(value)); &#125;else &#123; Buffer buffer = new Buffer(); Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8); JsonWriter jsonWriter = gson.newJsonWriter(writer); adapter.write(jsonWriter, value); jsonWriter.close(); return RequestBody.create(MEDIA_TYPE_JSON, buffer.readByteString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle插件开发]]></title>
    <url>%2F2016%2F08%2F03%2FGradler%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[Android Studio上的Android项目是通过Gradle构建的，Gradle插件是使用Groovy进行开发的，而Groovy是可以兼容Java，功能强大，兼容性好，所以学习一些基本的Gradle的知识是很有必要的。学习插件开发最开始的目的是实现一个多渠道打包（美团提出的方案），可后来发现Java中对Apk的操作有很多的问题，使用Python没有问题，使用Python又不方便与Gradle系统集成，所以项目就搁置了。 1.项目目录我们可以通过Android Studio来开发Gradle插件。（1）新建一个Android项目。（2）新建一个Module项目，类型选择Java Library。（3）将新建的Module中除了build.gradle文件外的其余文件全都删除，然后删除build.gradle文件中的所有内容。（4）在新建的module中新建文件夹src，接着在src文件目录下新建main文件夹，在main目录下新建groovy目录，这时候groovy文件夹会被Android识别为groovy源码目录。除了在main目录下新建groovy目录外，你还要在main目录下新建resources目录，同理resources目录会被自动识别为资源文件夹。在groovy目录下新建项目包名，就像Java包名那样。resources目录下新建文件夹META-INF，META-INF文件夹下新建gradle-plugins文件夹。这样，就完成了gradle 插件的项目的整体搭建，之后就是小细节了。目前，项目的结构是这样的。 2.开发2.1 配置gradle在Module中build.gradle中添加下面内容。在这个脚本里使用groovy插件编译groovy源码，声明gradleAPI作为即时编译依赖，apply plugin: ‘maven’ 是用来创建一个插件jar文件并且存储在本地maven库里。123456789101112131415161718192021222324apply plugin: 'groovy'apply plugin: 'maven'dependencies &#123; compile gradleApi() compile localGroovy()&#125;repositories &#123; mavenCentral()&#125;///下面是maven方面的信息 后面会使用到group='com.caij'version='1.0.0'uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri('../repo')) &#125; &#125;&#125; 2.2 编写插件创建一个自己的插件，并添加任务123456789101112package com.caij.plugin1import org.gradle.api.Pluginimport org.gradle.api.Projectclass MyCustomPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; project.task('myTask') &lt;&lt; &#123; println "Hi this is plugin" &#125; &#125;&#125; 2.3 指定插件实现类在gradle-plugins目录下创建一个properties类型的文件，文件名很重要，后面添加插件的时候会用到，apply plugin ‘java’， ‘java’就是文件的文件名。在properties文件中添加：implementation-class=com.caij.plugin1.MyCustomPlugin 2.4 编译插件上传本地仓库运行uploadArchives 任务，等待执行完成 2.5 测试创建一个Module, 类型选择Android Library， 在Module中build中添加下面内容123456789101112buildscript &#123; repositories &#123; maven &#123; url uri('../repo') &#125; &#125; dependencies &#123; //group:插件项目的名字：version classpath 'com.caij:plugin1:1.0.0' &#125;&#125;apply plugin: 'test.plugin' 你会看到有一个myTask的任务，执行任务。 3.扩展Gradle插件开发二Android多渠道打包插件项目]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义列表多图片ViewGroup]]></title>
    <url>%2F2016%2F06%2F10%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8%E5%A4%9A%E5%9B%BE%E7%89%87View.html</url>
    <content type="text"><![CDATA[在列表中展示图片是非常常用的功能，微信、微博、qq都有同样的功能， 如果针对不同数量的图片采用不同的type将会有很多类型，会造成列表卡顿，RecyclerView中嵌套RecyclerView也是一种非常不好的方案。所以需要自定义ViewGroup解决这个问题。 1.创建创建WeiboItemPicsView继承ViewGroup12345678910111213141516171819202122public class WeiboItemPicsView extends ViewGroup implements View.OnClickListener, ImageInterface, Runnable &#123; public WeiboItemPicsView(Context context) &#123; super(context); init(context); &#125; public WeiboItemPicsView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public WeiboItemPicsView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public WeiboItemPicsView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); init(context); &#125;&#125; 2.初始化初始化， 主要完成子View的添加12345678910private void init(Context context) &#123; addItemViews(); mSpaceWidth = getResources().getDimensionPixelSize(R.dimen.weibo_image_space);&#125;protected void addItemViews() &#123; for (int i = 0; i &lt; 9; i ++) &#123; addView(createImageView(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)); &#125;&#125; 3.测量12345678910111213141516@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int width = MeasureSpec.getSize(widthMeasureSpec); int availableWidth = width - getPaddingLeft() - getPaddingRight(); int height = 0; if (mPicUrls != null &amp;&amp; mPicUrls.size() != 0) &#123; if (mPicUrls.size() == 1) &#123; height = measureChildOnOneImage(availableWidth); &#125;else &#123; height = measureChildOnMultipleImage(availableWidth); &#125; &#125;// LogUtil.d(this, "onMeasure width = %s height = %s", width, height); height = height + getPaddingTop() + getPaddingBottom(); setMeasuredDimension(width, height);&#125; MeasureSpec可以自行google，控件是根据手机宽度控制子View的宽高。 对于单张图片单独处理，需要根据图片宽高来控制View的宽高123456789101112131415161718192021222324252627@Overrideprotected int measureChildOnOneImage(int availableWidth) &#123; View child = getChildAt(0); int imageHeight = 0; if (child != null &amp;&amp; child.getVisibility() != GONE) &#123; int imageWidth; PicUrl picUrl = mPicUrls.get(0); if (picUrl.getHeight() &gt; 0 &amp;&amp; picUrl.getWidth() &gt; 0) &#123; if (picUrl.getWidth() * 1.0f / picUrl.getHeight() &lt; MAX_RADIO) &#123; //宽比高小很多 竖着的图 imageWidth = (int) (availableWidth * 1.0f / 2); imageHeight = (int) (imageWidth * 1.34f); &#125; else if (picUrl.getHeight() * 1.0f / picUrl.getWidth() &lt; MAX_RADIO) &#123;//宽比高大很多 横着的图 imageWidth = (int) (availableWidth * 1.0f / 3 * 2); imageHeight = (int) (imageWidth / 1.34f); &#125; else &#123; //接近正方形 imageWidth = (int) (availableWidth * 1.0f / 3 * 2); imageHeight = imageWidth; &#125; &#125; else &#123; //没有宽度信息就是默认正方形 imageWidth = (int) (availableWidth * 1.0f / 3 * 2); imageHeight = imageWidth; &#125; child.measure(MeasureSpec.makeMeasureSpec(imageWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(imageHeight, MeasureSpec.EXACTLY)); &#125; return imageHeight;&#125; 对于多张图片，大小都是控件大小的1/3123456789101112131415161718@Overrideprotected int measureChildOnMultipleImage(int availableWidth) &#123; int defaultImageWidth = (availableWidth - 2 * mSpaceWidth) / 3; int imageLine = mPicUrls.size() == 4 ? 2 : mPicUrls.size() / 4 + 1; int height = defaultImageWidth * imageLine + (imageLine - 1) * mSpaceWidth; for (int i = 0; i &lt; getChildCount(); i ++) &#123; View child = getChildAt(i); if (child.getVisibility() == View.GONE) &#123; continue; &#125; child.measure(MeasureSpec.makeMeasureSpec(defaultImageWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(defaultImageWidth, MeasureSpec.EXACTLY)); &#125; return height;&#125; 4.定位根据控件的Index确定View的位置12345678910111213141516171819202122232425262728293031323334353637383940@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mPicUrls == null || mPicUrls.size() == 0) return; for (int i = 0; i &lt; getChildCount(); i++) &#123; ItemImageView childView = (ItemImageView) getChildAt(i); int startX = getPaddingLeft(); int startY = getPaddingTop(); if (childView.getVisibility() == View.GONE) &#123; continue; &#125; if (i &lt; mPicUrls.size()) &#123; if (mPicUrls.size() == 1) &#123; childView.layout(startX, startY, startX + childView.getMeasuredWidth(), startY + childView.getMeasuredHeight()); &#125;else if (mPicUrls.size() == 4) &#123; int imageWidth = childView.getMeasuredWidth(); int line = i / 2; // 0 1 2 int column = i % 2;// 0 1 2 int left = startX + column * imageWidth + column * mSpaceWidth; int top = startY + line * imageWidth + line * mSpaceWidth; int right = left + imageWidth; int button = top + imageWidth; childView.layout(left, top, right, button);// LogUtil.d(this, "item image index = %s left = %s top = %s right = %s button = %s",// i, left, top, right, button); &#125;else &#123; int imageWidth = childView.getMeasuredWidth(); int line = i / 3; // 0 1 2 int column = i % 3;// 0 1 2 int left = startX + column * imageWidth + column * mSpaceWidth; int top = startY + line * imageWidth + line * mSpaceWidth; int right = left + imageWidth; int button = top + imageWidth; childView.layout(left, top, right, button);// LogUtil.d(this, "item image index = %s left = %s top = %s right = %s button = %s",// i, left, top, right, button); &#125; &#125; &#125;&#125; 5.加载图片设置控件显示， 对于单张图片控件复用需要判断是否宽高相同。post runnable 这个很重要，因为加载图片需要在View测量完以后才会有大小数据，所以在通过这个方式使加载图片在View测量后。123456789101112131415161718192021222324252627282930313233public void setPics(List&lt;PicUrl&gt; picUrls) &#123; if (null == picUrls || picUrls.size() == 0) &#123; setVisibility(GONE); &#125;else &#123; setVisibility(VISIBLE); for (int i = 0; i &lt; getChildCount(); i++) &#123; if (i &lt; picUrls.size()) &#123; getChildAt(i).setVisibility(VISIBLE); &#125;else &#123; getChildAt(i).setVisibility(GONE); &#125; &#125; //当只有一张的时候复用 图片宽度是有变化 需要判断 boolean isNeedRequestLayout = false; if (mPicUrls != null &amp;&amp; mPicUrls.size() == picUrls.size() &amp;&amp; mPicUrls.size() == 1 &amp;&amp; !isImageWidthAndHeightSame(mPicUrls.get(0), picUrls.get(0))) &#123; //这个时候图片长度一样 isNeedRequestLayout = true; &#125; if (isNeedRequestLayout &amp;&amp; !isLayoutRequested()) &#123; requestLayout(); &#125; this.mPicUrls = picUrls; //因为请求重新绘制requestLayout是通过主线程handler发送消息， 这个再通过handler发送消息展示图片就会在绘制以后 post(this); &#125;&#125; 源码地址]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fresco浅析]]></title>
    <url>%2F2016%2F05%2F10%2FFresco%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[Fresco是facebook出的图片加载库，功能强大，学习成本比较高。支持基本的图片加载、Gif图片加载、JPEG图片的渐进加载（和电脑浏览器一样）、显示图片加载进度。相对于Glide的主要优点是支持图片渐进加载，显示图片加载进度，在Api19以下通过匿名共享内存缓存图片。本文章主要分析Fresco不同的地方。 1.不同点分析1.1 图片的加载。1.1.1 NetworkFetchProducer.java1234567891011@Overridepublic void produceResults(Consumer&lt;EncodedImage&gt; consumer, ProducerContext context) &#123;...mNetworkFetcher.fetch( fetchState, new NetworkFetcher.Callback() &#123; @Override public void onResponse(InputStream response, int responseLength) throws IOException &#123; NetworkFetchProducer.this.onResponse(fetchState, response, responseLength); &#125; &#125;);&#125; 这个是网络加载图片开始步骤，获取服务器图片流。 1234567891011121314151617181920212223242526272829private void onResponse( FetchState fetchState, InputStream responseData, int responseContentLength) throws IOException &#123; final PooledByteBufferOutputStream pooledOutputStream; if (responseContentLength &gt; 0) &#123; pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength); &#125; else &#123; pooledOutputStream = mPooledByteBufferFactory.newOutputStream(); &#125; final byte[] ioArray = mByteArrayPool.get(READ_SIZE); try &#123; int length; while ((length = responseData.read(ioArray)) &gt;= 0) &#123; if (length &gt; 0) &#123; pooledOutputStream.write(ioArray, 0, length); maybeHandleIntermediateResult(pooledOutputStream, fetchState); float progress = calculateProgress(pooledOutputStream.size(), responseContentLength); fetchState.getConsumer().onProgressUpdate(progress); &#125; &#125; mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size()); handleFinalResult(pooledOutputStream, fetchState); &#125; finally &#123; mByteArrayPool.release(ioArray); pooledOutputStream.close(); &#125;&#125; (1)创建PooledByteBufferOutputStream缓冲流缓存数据。(2)向PooledByteBufferOutputStream写入数据，回调加载进度，判断是否需要渐进显示图片。(3)完成以后显示图片。 1234567891011121314151617181920212223242526272829private void maybeHandleIntermediateResult( PooledByteBufferOutputStream pooledOutputStream, FetchState fetchState) &#123; final long nowMs = SystemClock.uptimeMillis(); if (shouldPropagateIntermediateResults(fetchState) &amp;&amp; nowMs - fetchState.getLastIntermediateResultTimeMs() &gt;= TIME_BETWEEN_PARTIAL_RESULTS_MS) &#123; fetchState.setLastIntermediateResultTimeMs(nowMs); fetchState.getListener() .onProducerEvent(fetchState.getId(), PRODUCER_NAME, INTERMEDIATE_RESULT_PRODUCER_EVENT); notifyConsumer(pooledOutputStream, false, fetchState.getConsumer()); &#125;&#125;private void notifyConsumer( PooledByteBufferOutputStream pooledOutputStream, boolean isFinal, Consumer&lt;EncodedImage&gt; consumer) &#123; CloseableReference&lt;PooledByteBuffer&gt; result = CloseableReference.of(pooledOutputStream.toByteBuffer()); EncodedImage encodedImage = null; try &#123; encodedImage = new EncodedImage(result); encodedImage.parseMetaData(); consumer.onNewResult(encodedImage, isFinal); &#125; finally &#123; EncodedImage.closeSafely(encodedImage); CloseableReference.closeSafely(result); &#125;&#125; 判断是否需要渐进加载显示图片。 1.2 图片的解析1.2.1 ImagePipelineFactory.java12345678910111213141516public static PlatformDecoder buildPlatformDecoder( PoolFactory poolFactory, boolean decodeMemoryFileEnabled, boolean webpSupportEnabled) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; return new ArtDecoder( poolFactory.getBitmapPool(), poolFactory.getFlexByteArrayPoolMaxNumThreads()); &#125; else &#123; if (decodeMemoryFileEnabled &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123; return new GingerbreadPurgeableDecoder(webpSupportEnabled); &#125; else &#123; return new KitKatPurgeableDecoder(poolFactory.getFlexByteArrayPool()); &#125; &#125;&#125; Fresco针对系统的版本做了不同的图片解析方案。 1.2.1 PlatformDecoder.java12345678CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage( final EncodedImage encodedImage, Bitmap.Config bitmapConfig); CloseableReference&lt;Bitmap&gt; decodeJPEGFromEncodedImage( EncodedImage encodedImage, Bitmap.Config bitmapConfig, int length); decodeFromEncodedImage是对完整图片的解析，decodeJPEGFromEncodedImage是解析JPEG渐进中的图片。 1.2.3 GingerbreadPurgeableDecoder.java123456789101112131415161718192021222324protected Bitmap decodeFileDescriptorAsPurgeable( CloseableReference&lt;PooledByteBuffer&gt; bytesRef, int inputLength, byte[] suffix, BitmapFactory.Options options) &#123; MemoryFile memoryFile = null; try &#123; memoryFile = copyToMemoryFile(bytesRef, inputLength, suffix); FileDescriptor fd = getMemoryFileDescriptor(memoryFile); Bitmap bitmap; if (mWebpSupportEnabled) &#123; bitmap = sWebpBitmapFactory.decodeFileDescriptor(fd, null, options); &#125; else &#123; bitmap = BitmapFactory.decodeFileDescriptor(fd, null, options); &#125; return Preconditions.checkNotNull(bitmap, "BitmapFactory returned null"); &#125; catch (IOException e) &#123; throw Throwables.propagate(e); &#125; finally &#123; if (memoryFile != null) &#123; memoryFile.close(); &#125; &#125;&#125; 针对API 19以下使用了匿名共享内存，减少Java Heap内存。匿名共享内存可查看Android系统匿名共享内存Ashmem（Anonymous Shared Memory）简要介绍和学习计划。 1.2.4 KitKatPurgeableDecoder.java12345678910111213141516171819protected Bitmap decodeByteArrayAsPurgeable( CloseableReference&lt;PooledByteBuffer&gt; bytesRef, BitmapFactory.Options options) &#123; final PooledByteBuffer pooledByteBuffer = bytesRef.get(); final int length = pooledByteBuffer.size(); final CloseableReference&lt;byte[]&gt; encodedBytesArrayRef = mFlexByteArrayPool.get(length); try &#123; final byte[] encodedBytesArray = encodedBytesArrayRef.get(); pooledByteBuffer.read(0, encodedBytesArray, 0, length); Bitmap bitmap = BitmapFactory.decodeByteArray( encodedBytesArray, 0, length, options); return Preconditions.checkNotNull(bitmap, "BitmapFactory returned null"); &#125; finally &#123; CloseableReference.closeSafely(encodedBytesArrayRef); &#125;&#125; API19 这个版本不支持匿名共享内存，Bitmap将在java memory中。这个是注释： The MemoryFile trick used in GingerbreadPurgeableDecoder does not work in KitKat. Here, weinstead use Java memory to store the encoded images, but make use of a pool to minimizeallocations. We cannot decode from a stream, as that does not support purgeable decodes. 1.2.5 ArtDecoder.java1234567891011121314public CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage( EncodedImage encodedImage, Bitmap.Config bitmapConfig) &#123; final BitmapFactory.Options options = getDecodeOptionsForStream(encodedImage, bitmapConfig); boolean retryOnFail=options.inPreferredConfig != Bitmap.Config.ARGB_8888; try &#123; return decodeStaticImageFromStream(encodedImage.getInputStream(), options); &#125; catch (RuntimeException re) &#123; if (retryOnFail) &#123; return decodeFromEncodedImage(encodedImage, Bitmap.Config.ARGB_8888); &#125; throw re; &#125;&#125; API21及以上，新增了Options inBitmap属性，这个属性支持Bitmap创建时复用之前无用的Bitmap。 2.缺点分析1.1 图片处理问题（1）不支持根据ImageView宽高处理图片（2）图片压缩不够细腻。对应大图和长图的压缩有问题；没有Transformation的过程，意味不会根据ScaleType处理图片，只有更具simple size 压缩图片。所有的ScaleType都是通过定义Drawable和通过矩阵来实现最终效果，这种方式感觉浪费系统资源。（3）扩展性不够好，代码复杂，重构和上手成本高。]]></content>
      <categories>
        <category>图片加载</category>
      </categories>
      <tags>
        <tag>Fresco</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized和Lock解析]]></title>
    <url>%2F2016%2F04%2F06%2Fsynchronized%E5%92%8CLock%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[Java中提供了synchronized和lock两种锁机制保证线程安全。 1 synchronized和lock的介绍和区别(1)synrhronized关键字简洁、清晰、语义明确，其应用层的语义是可以把任何一个非null对象作为”锁”，当synchronized作用在方法上时，锁住的便是对象实例（this）；当作用在静态方法时锁住的便是对象对应的Class实例，因为Class数据存在于永久带，因此静态方法锁相当于该类的一个全局锁；当synchronized作用于某一个对象实例时，锁住的便是对应的代码块。synrhronized是控制整块代码，等待线程不可中断，所有锁竞争都是非公平的，扩展低，有些场景不适合。(2)lock需要自己加锁和解锁，通过lock()和unlock()显示指出，一般会在finally块中写unlock()以防死锁。可以中断等待线程，提供公平锁和非公平锁。 2 synchronized和lock的机制synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。这个问题在jdk1.6以上已经优化，和lock的原理类似。而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。 3 synchronized源码解析(转:深入JVM锁机制1-synchronized)3.1线程状态及状态转换当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程：1)Contention List：所有请求锁的线程将被首先放置到该竞争队列2)Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List3)Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set4)OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck5)Owner：获得锁的线程称为Owner6)!Owner：释放锁的线程下图反映了个状态转换关系： 新请求锁的线程将首先被加入到ConetentionList中，当某个拥有锁的线程（Owner状态）调用unlock之后，如果发现EntryList为空则从ContentionList中移动线程到EntryList，下面说明下ContentionList和EntryList的实现方式： 3.2ContentionList虚拟队列ContentionList并不是一个真正的Queue，而只是一个虚拟队列，原因在于ContentionList是由Node及其next指针逻辑构成，并不存在一个Queue的数据结构。ContentionList是一个后进先出（LIFO）的队列，每次新加入Node时都会在队头进行，通过CAS改变第一个节点的的指针为新增节点，同时设置新增节点的next指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个Lock-Free的队列。因为只有Owner线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了CAS的ABA问题。 3.3 EntryListEntryList与ContentionList逻辑上同属等待队列，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立EntryList。Owner线程在unlock时会从ContentionList中迁移线程到EntryList，并会指定EntryList中的某个线程（一般为Head）为Ready（OnDeck）线程。Owner线程并不是把锁传递给OnDeck线程，只是把竞争锁的权利交给OnDeck，OnDeck线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在Hotspot中把OnDeck的选择行为称之为“竞争切换”。 OnDeck线程获得锁后即变为owner线程，无法获得锁则会依然留在EntryList中，考虑到公平性，在EntryList中的位置不发生变化（依然在队头）。如果Owner线程被wait方法阻塞，则转移到WaitSet队列；如果在某个时刻被notify/notifyAll唤醒，则再次转移到EntryList。 4 lock源码解析(转:深入JVM锁机制2-Lock)4.1 锁实现简单说来，AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态，经过调查线程的显式阻塞是通过调用LockSupport.park()完成，而LockSupport.park()则调用sun.misc.Unsafe.park()本地方法，再进一步，HotSpot在Linux中中通过调用pthread_mutex_lock函数把线程交给系统内核进行阻塞。该队列如图：与synchronized相同的是，这也是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系。令人疑惑的是为什么采用CLH队列呢？原生的CLH队列是用于自旋锁，但Doug Lea把其改造为阻塞锁。当有线程竞争锁时，该线程会首先尝试获得锁，这对于那些已经在队列中排队的线程来说显得不公平，这也是非公平锁的由来，与synchronized实现类似，这样会极大提高吞吐量。如果已经存在Running线程，则新的竞争线程会被追加到队尾，具体是采用基于CAS的Lock-Free算法，因为线程并发对Tail调用CAS可能会导致其他线程CAS失败，解决办法是循环CAS直至成功。AbstractQueuedSynchronizer的实现非常精巧，令人叹为观止，不入细节难以完全领会其精髓，下面详细说明实现过程： 4.2 流程1234567891011121314151617181920212223242526272829303132333435final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125;public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; //公平锁和非公平锁在的区别，自己可以去详细看看 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 该方法会首先判断当前状态，如果c==0说明没有线程正在竞争该锁，如果不c !=0 说明有线程正拥有了该锁。如果发现c==0，则通过CAS设置该状态值为acquires,acquires的初始调用值为1，每次线程重入该锁都会+1，每次unlock都会-1，但为0时释放锁。如果CAS设置成功，则可以预计其他任何线程调用CAS都不会再成功，也就认为当前线程得到了该锁，也作为Running线程，很显然这个Running线程并未进入等待队列。这个也是非公平锁的判断的地方，一个线程进来可以竞争锁，而公平锁会判断队列中是否有线程，有线程是不能去竞争锁。如果c !=0 但发现自己已经拥有锁，只是简单地++acquires，并修改status值，但因为没有竞争，所以通过setStatus修改，而非CAS，也就是说这段代码实现了偏向锁的功能，并且实现的非常漂亮。 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 没有竞争锁成功则将当前线程添加到队列的尾节点，其中参数mode是独占锁还是共享锁，默认为null，独占锁。追加到队尾的动作分两步：1)如果当前队尾已经存在(tail!=null)，则使用CAS把当前线程更新为Tail2)如果当前Tail为null或则线程调用CAS设置队尾失败，则通过enq方法继续设置Tail 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) //初始化头结点和tail节点，头结点是一个空Node tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 该方法就是循环调用CAS，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾（或设置队头）。总而言之，addWaiter的目的就是通过CAS把当前现在追加到队尾，并返回包装后的Node实例。 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 仔细看看这个方法是个无限循环，感觉如果p == head &amp;&amp; tryAcquire(arg)条件不满足循环将永远无法结束，当然不会出现死循环，奥秘在于第12行的parkAndCheckInterrupt会把当前线程挂起，从而阻塞住线程的调用栈。首先他还会竞争一下锁。不成功则看是否可以阻塞线程。 12345678910111213141516private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 还用Node包装了各种线程状态:SIGNAL(-1) ：线程的next线程正/已被阻塞，当该线程release或cancel时要重新这个后继线程(unpark)CANCELLED(1)：因为超时或中断，该线程已经被取消CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了Condition.await而被阻塞PROPAGATE(-3)：传播共享锁0：0代表无状态 这个方法进来的时候waitStatus是初始值无状态的0，所以执行compareAndSetWaitStatus(pred, ws, Node.SIGNAL)，将waitStatus设置为SIGNAL，那表示他的next节点必须是park状态， 继续上一个方法循环再次进这个方法则return true，当前加入的节点则会调用parkAndCheckInterrupt park线程。 如果前继节点状态为CANCELLED(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，返回false，acquireQueued方法的无限循环将递归调用该方法，直至规则1返回true。 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; LockSupport.park最终把线程交给系统（Linux）内核进行阻塞。 5. Lock VS SynchronizedAbstractQueuedSynchronizer通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。synchronized的底层也是一个基于CAS操作的等待队列，但JVM实现的更精细，把等待队列分为ContentionList和EntryList，目的是为了降低线程的出列速度；当然也实现了偏向锁，从数据结构来说二者设计没有本质区别。但synchronized还实现了自旋锁，并针对不同的系统和硬件体系进行了优化，而Lock则完全依靠系统阻塞挂起等待线程。当然Lock比synchronized更适合在应用层扩展，可以继承AbstractQueuedSynchronizer定义各种实现，比如实现读写锁（ReadWriteLock），公平或不公平锁；同时，Lock对应的Condition也比wait/notify要方便的多、灵活的多。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ConcurrentLinkedQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentLinkedQueue源码解析]]></title>
    <url>%2F2016%2F03%2F28%2FConcurrentLinkedQueue%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[ConcurrentLinkedQueue是使用非阻塞的方式来实现线程安全队列，采用CAS(Compare and Swap)无锁算法。非阻塞同步算法与CAS(Compare and Swap)无锁算法 - Mainz 1 结构ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tair节点等于head节点。CAS（乐观锁算法）的基本假设前提CAS比较与交换的伪代码可以表示为：1234do&#123; 备份旧数据； 基于旧数据构造新数据； &#125;while(!CAS( 内存地址，备份的旧数据，新数据 )) 2.入队第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。第三步添加元素3，设置tail节点的next节点为元素3节点。第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。1234567891011121314151617181920212223public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); Node&lt;E&gt; n = new Node&lt;E&gt;(e); retry: for (;;) &#123; Node&lt;E&gt; t = tail; Node&lt;E&gt; p = t; for (int hops = 0; ; hops++) &#123; Node&lt;E&gt; next = succ(p); if (next != null) &#123; if (hops &gt; HOPS &amp;&amp; t != tail) continue retry; p = next; &#125; else if (p.casNext(null, n)) &#123;//如果p是尾节点，则设置p节点的next节点为入队节点。 if (hops &gt;= HOPS) casTail(t, n); // Failure is OK. return true; &#125; else &#123; p = succ(p); &#125; &#125; &#125;&#125; (1)创建临时变量保存tail节点。(2)取出tail的next节点。(3)如果next为null，表示p是尾节点，则将插入节点放入p.next。(4)更新tail的值。允许失败(5)如果插入不成功则再次判断p是否存在next。 就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的 commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。 3.出队12345678910111213141516171819202122public E poll() &#123; Node&lt;E&gt; h = head; Node&lt;E&gt; p = h; for (int hops = 0; ; hops++) &#123; E item = p.getItem(); if (item != null &amp;&amp; p.casItem(item, null)) &#123; if (hops &gt;= HOPS) &#123; Node&lt;E&gt; q = p.getNext(); updateHead(h, (q != null) ? q : p); &#125; return item; &#125; Node&lt;E&gt; next = succ(p); if (next == null) &#123; updateHead(h, p); break; &#125; p = next; &#125; return null;&#125; 首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ConcurrentLinkedQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码解析]]></title>
    <url>%2F2016%2F03%2F23%2FConcurrentHashMap%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[ConcurrentHashMap是线程安全的HashMap，比HashTable的效率高，采用分块加锁机制。 1 结构图ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 2.与HashTable对比 3.成员变量1final Segment&lt;K,V&gt;[] segments; 4.流程分析123456public V put(K key, V value) &#123; if (value == null) throw new NullPointerException(); int hash = hash(key.hashCode()); return segmentFor(hash).put(key, hash, value, false);&#125; 首先通过Hash值定位Segment值。再Hash是为了减少数据碰撞。 123456789101112131415161718192021222324252627282930V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; lock(); try &#123; int c = count; if (c++ &gt; threshold) // ensure capacity rehash(); HashEntry&lt;K,V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashEntry&lt;K,V&gt; first = tab[index]; HashEntry&lt;K,V&gt; e = first; while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) e = e.next; V oldValue; if (e != null) &#123; oldValue = e.value; if (!onlyIfAbsent) e.value = value; &#125; else &#123; oldValue = null; ++modCount; tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value); count = c; // write-volatile &#125; return oldValue; &#125; finally &#123; unlock(); &#125; &#125; 首先是加锁，然后添加数据，添加数据的过程和HashMap类似，最后释放锁。 123456789101112131415V get(Object key, int hash) &#123; if (count != 0) &#123; // read-volatile HashEntry&lt;K,V&gt; e = getFirst(hash); while (e != null) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; V v = e.value; if (v != null) return v; return readValueUnderLock(e); // recheck &#125; e = e.next; &#125; &#125; return null;&#125; get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor源码解析]]></title>
    <url>%2F2016%2F02%2F24%2FThreadPoolExecutor%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[线程池程序开发中经常用到，比如网络和本地数据的访问 ，使用线程池能有效的控制线程数量，避免线程的频繁创建和回收。 1.成员变量1private final BlockingQueue&lt;Runnable&gt; workQueue; 表示任务队列。 1private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); Worker可以理解为发动机，每个Worker都会开启一个线程，workers表示存放线程的集合。 1private volatile long keepAliveTime; keepAliveTime表示线程活跃时间。因为线程池有核心线程个数，有最大线程个数，当线程池中的线程大于核心线程数时，线程的闲置时间超过keepAliveTime将会被回收。 12345private volatile int corePoolSize;private volatile int maximumPoolSize;private volatile int poolSize; 分别表示核心线程个数，最大线程个数，当前线程个数。 1private volatile ThreadFactory threadFactory; 用于创建线程的工厂。 12private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 当线程池中的线程数量和任务数量都达到最大值，就会抛出异常给RejectedExecutionHandler处理。 2.核心方法流程12345678910public void execute(Runnable command) &#123; if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; else if (!addIfUnderMaximumPoolSize(command)) reject(command); // is shutdown or saturated &#125;&#125; (1)当当前线程个数小于核心线程个数，则会调用addIfUnderCorePoolSize。(2)当当前线程个数大于核心线程个数进行下一步处理。 123456789101112private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123; Thread t = null; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING) t = addThread(firstTask); &#125; finally &#123; mainLock.unlock(); &#125; return t != null;&#125; 判断前线程个数小于核心线程个数，true则添加线程。 1234567891011121314151617181920212223private Thread addThread(Runnable firstTask) &#123; Worker w = new Worker(firstTask); Thread t = threadFactory.newThread(w); boolean workerStarted = false; if (t != null) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); w.thread = t; workers.add(w); int nt = ++poolSize; if (nt &gt; largestPoolSize) largestPoolSize = nt; try &#123; t.start(); workerStarted = true; &#125; finally &#123; if (!workerStarted) workers.remove(w); &#125; &#125; return t;&#125; 创建新线程并启动。 ThreadPoolExecutor.Worker12345678910111213public void run() &#123; try &#123; hasRun = true; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); &#125;&#125; 首先运行初始化的第一个任务，后续从队列中获取任务。 ThreadPoolExecutor.Worker1234567891011121314151617181920212223242526Runnable getTask() &#123; for (;;) &#123; try &#123; int state = runState; if (state &gt; SHUTDOWN) return null; Runnable r; if (state == SHUTDOWN) // Help drain queue r = workQueue.poll(); else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS); else r = workQueue.take(); if (r != null) return r; if (workerCanExit()) &#123; if (runState &gt;= SHUTDOWN) // Wake up others interruptIdleWorkers(); return null; &#125; // Else retry &#125; catch (InterruptedException ie) &#123; // On interruption, re-check runState &#125; &#125;&#125; (1)线程已经停止，直接把任务队列中的数据获取出来，不阻塞登录获取。(2)这里第二个判断条件是回收线程的重要的地方，在约定时间内获取任务，如果没有则返回null。(3)阻塞等待获取任务。(4)判断当前线程是否可用回收。 3. 添加任务处理流程当一个任务通过execute(Runnable)方法欲添加到线程池时：如果当前线程池中的数量小于corePoolSize，并线程池处于Running状态，创建并添加的任务。如果当前线程池中的数量等于corePoolSize，并线程池处于Running状态，缓冲队列 workQueue未满，那么任务被放入缓冲队列、等待任务调度执行。如果当前线程池中的数量大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量小于maximumPoolSize，新提交任务会创建新线程执行任务。如果当前线程池中的数量大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量等于maximumPoolSize，新提交任务由Handler处理。当线程池中的线程大于corePoolSize时，多余线程空闲时间超过keepAliveTime时，会关闭这部分线程。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap源码解析]]></title>
    <url>%2F2016%2F02%2F24%2FLinkedHashMap%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[之前分析过HashMap的源码，LinkedHashMap是继承自HashMap，将HashMap中的数据增加了一种链表结构。大部分方法是相同的，流程也一样，不同是createEntry和transfer方法，还有Entry的数据结构。Entry在之前的基础上添加了before和after。 LinkedHashMap提供特殊的构造方法来创建链接哈希映射，该哈希映射的迭代顺序就是最后访问其条目的顺序，从近期访问最少到近期访问最多的顺序（访问顺序）。这种映射很适合构建 LRU 缓存。Android中的图片缓存中经常用到。 2.成员变量12private transient Entry&lt;K,V&gt; header; //表示维护链表的头节点。private final boolean accessOrder; //表示是否按照最后访问其条目的顺序重新排序。 表示任务队列。 3.方法1234567void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; e.addBefore(header); size++;&#125; 在之前的基础上还维护了一种链表结构。将新添加的数据放在链表最后面 123456private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; 这个方法就是将当期元素放在列表的最后面。 1234567public V get(Object key) &#123; Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; e.recordAccess(this); return e.value;&#125; getEntry是HashMap中的方法，没有重写。获取元素后会重新排序链表。 12345678void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125;&#125; accessOrder表示是否需要重新排序。 1234567891011private void remove() &#123; before.after = after; after.before = before;&#125;private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; 这两个方法就是将当期元素从当前位置移动到最后的位置。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码解析]]></title>
    <url>%2F2016%2F02%2F24%2FHashMap%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 1.结构图 2.成员变量1234final float loadFactor; //加载因子int threshold; //当前允许数据存放的总数量transient int size; //HashMap中的数据数量transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; 表示任务队列。 3.方法12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; (1)如果初始化table。(2)计算key的hash值。(3)通过hash值计算value在table中的index。(4)判断key是否存在，如果存在直接覆盖。(5)添加key-value。 1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 这里将对象的hashCode再hash是为了减少冲突。比如Obj1的hashCode为1000 0000 0000 0000， Obj2的hashCode为1111 0000 0000 0000，当length没有足够大，使用indexFor方法获取的index将相同;使用再hash后的Obj1的hashCode为1000 1001 0000 1000， Obj2的hashCode为1111 1110 1110 1111，尽量让1变得均匀，防止低位不变，高位变化时，造成的hash冲突，使用indexFor方法获取的index将变得不同。 12345678private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity);&#125; capacity相当于table的总长度，threshold是table总长度乘以加载因子。 1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1);&#125; 这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的 n 次方，这是HashMap在查找速度上的优化。 这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。 当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：12345h &amp; (table.length-1) hash table.length-1 8 &amp; (15-1)： 0100 &amp; 1110 = 0100 9 &amp; (15-1)： 0101 &amp; 1110 = 0100 8 &amp; (16-1)： 0100 &amp; 1111 = 0100 9 &amp; (16-1)： 0101 &amp; 1111 = 0101 从上面的例子中可以看出：当它们和15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞， 8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现， 当数组长度为15的时候，hash值会与15-1（1110）进行“与”，那么 最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了， 空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时， 即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算， 就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; (1)判断是否已经达到允许数据存放的总数量。如果true则扩充table的容量， 12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; 当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过160.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 12345void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 在index上存放Entry，这里是一个链表结构，先将在这个index上的Entry取出来，然后放在新生成Entry.next中。这样就符合上面图中的数据结构。 123456789101112131415161718192021222324public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; (1)计算index。(2)获取table上index位置的值。(3)遍历链表。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp详解5]]></title>
    <url>%2F2016%2F01%2F14%2Fokhttp%E8%AF%A6%E8%A7%A3(5).html</url>
    <content type="text"><![CDATA[之前一张分析了http1.1协议下的流程，接下来分析http2.0的数据交互流程。 一、重要的类简述1.FramedTransport包装版的数据请求通道，包含httpConnection成员变量，所有的数据操作都是通过FramedConnection操作。 2.FramedConnection数据操作，包含FrameWriter和FrameReader，FramedConnection操作数据通过FrameWriter和FrameReader处理，而FrameWriter和FrameReader则是通过socket的source和sink处理数据。 3.FramedStream。http2.0支持多路复用技术，所以FramedStream是保存每个请求数据交互数据。 二、流程分析1.FramedTransport.java123456789101112@Override public void writeRequestHeaders(Request request) throws IOException &#123; if (stream != null) return; httpEngine.writingRequestHeaders(); boolean permitsRequestBody = httpEngine.permitsRequestBody(request); List&lt;Header&gt; requestHeaders = framedConnection.getProtocol() == Protocol.HTTP_2 ? http2HeadersList(request) : spdy3HeadersList(request); boolean hasResponseBody = true; stream = framedConnection.newStream(requestHeaders, permitsRequestBody, hasResponseBody); stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS); &#125; (1)首先生成请求头。(2)生成stream。 2.FramedConnection.java123456789101112131415161718192021222324252627282930313233343536private FramedStream newStream(int associatedStreamId, List&lt;Header&gt; requestHeaders, boolean out, boolean in) throws IOException &#123; boolean outFinished = !out; boolean inFinished = !in; FramedStream stream; int streamId; synchronized (frameWriter) &#123; synchronized (this) &#123; if (shutdown) &#123; throw new IOException("shutdown"); &#125; streamId = nextStreamId; nextStreamId += 2; stream = new FramedStream(streamId, this, outFinished, inFinished, requestHeaders); if (stream.isOpen()) &#123; streams.put(streamId, stream); setIdle(false); &#125; &#125; if (associatedStreamId == 0) &#123; frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, requestHeaders); &#125; else if (client) &#123; throw new IllegalArgumentException("client streams shouldn't have associated stream IDs"); &#125; else &#123; // HTTP/2 has a PUSH_PROMISE frame. frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders); &#125; &#125; if (!out) &#123; frameWriter.flush(); &#125; return stream;&#125; (1)创建stream。streamId是stream的唯一标识，每个请求对应一个streamId，传输数据的时候需要传递这个参数。(2)保存到streams中，并将连接状态设置为非限制。(3)发送请求头数据。 3.Http2.Writer.java1234567891011121314151617181920212223242526272829303132333435 @Override public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId, List&lt;Header&gt; headerBlock) throws IOException &#123; if (inFinished) throw new UnsupportedOperationException(); if (closed) throw new IOException("closed"); headers(outFinished, streamId, headerBlock); &#125;void headers(boolean outFinished, int streamId, List&lt;Header&gt; headerBlock) throws IOException &#123; if (closed) throw new IOException("closed"); hpackWriter.writeHeaders(headerBlock); long byteCount = hpackBuffer.size(); int length = (int) Math.min(maxFrameSize, byteCount); byte type = TYPE_HEADERS; byte flags = byteCount == length ? FLAG_END_HEADERS : 0; if (outFinished) flags |= FLAG_END_STREAM; frameHeader(streamId, length, type, flags); sink.write(hpackBuffer, length); if (byteCount &gt; length) writeContinuationFrames(streamId, byteCount - length); &#125;void frameHeader(int streamId, int length, byte type, byte flags) throws IOException &#123; if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags)); if (length &gt; maxFrameSize) &#123; throw illegalArgument("FRAME_SIZE_ERROR length &gt; %d: %d", maxFrameSize, length); &#125; if ((streamId &amp; 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId); writeMedium(sink, length); sink.writeByte(type &amp; 0xff); sink.writeByte(flags &amp; 0xff); sink.writeInt(streamId &amp; 0x7fffffff); &#125; &#125; (1)首先将请求头写入hpackBuffer中。hpackWriter其实就是将请求头数据压缩处理存放到hpackBuffer中。(2)frameHeader发送请求数据基本参数。(3)发送请求头数据。 FramedTransport.java 123@Override public Sink createRequestBody(Request request, long contentLength) throws IOException &#123; return stream.getSink();&#125; 获取Sink， 每个请求对应一个stream。 FramedTransport.java 123@Override public void finishRequest() throws IOException &#123; stream.getSink().close();&#125; 获取Sink， 每个请求对应一个stream。 6.FramedDataSource.java12345678910111213141516171819202122@Override public void close() throws IOException &#123; assert (!Thread.holdsLock(FramedStream.this)); synchronized (FramedStream.this) &#123; if (closed) return; &#125; if (!sink.finished) &#123; // Emit the remaining data, setting the END_STREAM flag on the last frame. if (sendBuffer.size() &gt; 0) &#123; while (sendBuffer.size() &gt; 0) &#123; emitDataFrame(true); &#125; &#125; else &#123; // Send an empty frame just so we can set the END_STREAM flag. connection.writeData(id, true, null, 0); &#125; &#125; synchronized (FramedStream.this) &#123; closed = true; &#125; connection.flush(); cancelStreamIfNecessary(); &#125; 7.FramedTransport.java12345@Override public Response.Builder readResponseHeaders() throws IOException &#123; return framedConnection.getProtocol() == Protocol.HTTP_2 ? readHttp2HeadersList(stream.getResponseHeaders()) : readSpdy3HeadersList(stream.getResponseHeaders());&#125; FramedStream.java 123456789101112public synchronized List&lt;Header&gt; getResponseHeaders() throws IOException &#123; readTimeout.enter(); try &#123; while (responseHeaders == null &amp;&amp; errorCode == null) &#123; waitForIo(); &#125; &#125; finally &#123; readTimeout.exitAndThrowIfTimedOut(); &#125; if (responseHeaders != null) return responseHeaders; throw new IOException("stream was reset: " + errorCode); &#125; 这里如果响应头还未返回，阻塞等待。接下来看接收数据。 9.Http2.Reader.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 @Override public boolean nextFrame(Handler handler) throws IOException &#123; try &#123; source.require(9); // Frame header size &#125; catch (IOException e) &#123; return false; // This might be a normal socket close. &#125; /* 0 1 2 3 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * | Length (24) |--- * | Type (8) | Flags (8) |--- * |R| Stream Identifier (31) | * +=+=============================================================+ * | Frame Payload (0...) ...--- */ int length = readMedium(source); if (length &lt; 0 || length &gt; INITIAL_MAX_FRAME_SIZE) &#123; throw ioException("FRAME_SIZE_ERROR: %s", length); &#125; byte type = (byte) (source.readByte() &amp; 0xff); byte flags = (byte) (source.readByte() &amp; 0xff); int streamId = (source.readInt() &amp; 0x7fffffff); // Ignore reserved bit. if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags)); switch (type) &#123; case TYPE_DATA: readData(handler, length, flags, streamId); break; case TYPE_HEADERS: readHeaders(handler, length, flags, streamId); break; case TYPE_PRIORITY: readPriority(handler, length, flags, streamId); break; case TYPE_RST_STREAM: readRstStream(handler, length, flags, streamId); break; case TYPE_SETTINGS: readSettings(handler, length, flags, streamId); break; case TYPE_PUSH_PROMISE: readPushPromise(handler, length, flags, streamId); break; case TYPE_PING: readPing(handler, length, flags, streamId); break; case TYPE_GOAWAY: readGoAway(handler, length, flags, streamId); break; case TYPE_WINDOW_UPDATE: readWindowUpdate(handler, length, flags, streamId); break; default: // Implementations MUST discard frames that have unknown or unsupported types. source.skip(length); &#125; return true; &#125; 这里根据服务器返回的类型保存数据。 10.Http2.Reader.java12345678910111213141516171819private void readHeaders(Handler handler, int length, byte flags, int streamId) throws IOException &#123; if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0"); boolean endStream = (flags &amp; FLAG_END_STREAM) != 0; short padding = (flags &amp; FLAG_PADDED) != 0 ? (short) (source.readByte() &amp; 0xff) : 0; if ((flags &amp; FLAG_PRIORITY) != 0) &#123; readPriority(handler, streamId); length -= 5; // account for above read. &#125; length = lengthWithoutPadding(length, flags, padding); List&lt;Header&gt; headerBlock = readHeaderBlock(length, padding, flags, streamId); handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);&#125; 11.FramedConnection.Reader.java123456789101112131415161718192021 @Override public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId, List&lt;Header&gt; headerBlock, HeadersMode headersMode) &#123;... FramedStream stream; synchronized (FramedConnection.this) &#123; // If we're shutdown, don't bother with this stream. if (shutdown) return; stream = getStream(streamId); if (stream == null) &#123; ... &#125; &#125; .... // Update an existing stream. stream.receiveHeaders(headerBlock, headersMode); if (inFinished) stream.receiveFin(); &#125; (1)根据streamId查找已存在的stream。(2)将数据保存在stream中。 12.FramedStream.java123456789101112131415161718192021222324252627282930void receiveHeaders(List&lt;Header&gt; headers, HeadersMode headersMode) &#123; assert (!Thread.holdsLock(FramedStream.this)); ErrorCode errorCode = null; boolean open = true; synchronized (this) &#123; if (responseHeaders == null) &#123; if (headersMode.failIfHeadersAbsent()) &#123; errorCode = ErrorCode.PROTOCOL_ERROR; &#125; else &#123; responseHeaders = headers; open = isOpen(); notifyAll(); &#125; &#125; else &#123; if (headersMode.failIfHeadersPresent()) &#123; errorCode = ErrorCode.STREAM_IN_USE; &#125; else &#123; List&lt;Header&gt; newHeaders = new ArrayList&lt;&gt;(); newHeaders.addAll(responseHeaders); newHeaders.addAll(headers); this.responseHeaders = newHeaders; &#125; &#125; &#125; if (errorCode != null) &#123; closeLater(errorCode); &#125; else if (!open) &#123; connection.removeStream(id); &#125;&#125; (1)保存headers。(2)唤醒等待。 13.FramedTransport.java123@Override public ResponseBody openResponseBody(Response response) throws IOException &#123; return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));&#125; 获取stream中的Source。下面继续分析Source中的数据获取。 14.FramedConnection.Reader.java123456789101112131415private void readData(Handler handler, int length, byte flags, int streamId) throws IOException &#123; // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED boolean inFinished = (flags &amp; FLAG_END_STREAM) != 0; boolean gzipped = (flags &amp; FLAG_COMPRESSED) != 0; if (gzipped) &#123; throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA"); &#125; short padding = (flags &amp; FLAG_PADDED) != 0 ? (short) (source.readByte() &amp; 0xff) : 0; length = lengthWithoutPadding(length, flags, padding); handler.data(inFinished, streamId, source, length); source.skip(padding); &#125; 还是通过第9步中获取数据。 15.FramedConnection.Reader.java12345678910@Override public void data(boolean inFinished, int streamId, BufferedSource source, int length) throws IOException &#123; ... FramedStream dataStream = getStream(streamId); ... dataStream.receiveData(source, length); if (inFinished) &#123; dataStream.receiveFin(); &#125;&#125; 16.FramedStream.java1234void receiveData(BufferedSource in, int length) throws IOException &#123; assert (!Thread.holdsLock(FramedStream.this)); this.source.receive(in, length);&#125; 17.FramedDataSource.java123456789101112131415161718192021222324252627282930313233343536373839void receive(BufferedSource in, long byteCount) throws IOException &#123; assert (!Thread.holdsLock(FramedStream.this)); while (byteCount &gt; 0) &#123; boolean finished; boolean flowControlError; synchronized (FramedStream.this) &#123; finished = this.finished; flowControlError = byteCount + readBuffer.size() &gt; maxByteCount; &#125; // If the peer sends more data than we can handle, discard it and close the connection. if (flowControlError) &#123; in.skip(byteCount); closeLater(ErrorCode.FLOW_CONTROL_ERROR); return; &#125; // Discard data received after the stream is finished. It's probably a benign race. if (finished) &#123; in.skip(byteCount); return; &#125; // Fill the receive buffer without holding any locks. long read = in.read(receiveBuffer, byteCount); if (read == -1) throw new EOFException(); byteCount -= read; // Move the received data to the read buffer to the reader can read it. synchronized (FramedStream.this) &#123; boolean wasEmpty = readBuffer.size() == 0; readBuffer.writeAll(receiveBuffer); if (wasEmpty) &#123; FramedStream.this.notifyAll(); &#125; &#125; &#125;&#125; 这里是一个自定义的Source来保存数据，不像http1.1直接使用socket包装的source。 18.HttpEngine.java1234public Response getResponse() &#123; if (userResponse == null) throw new IllegalStateException(); return userResponse;&#125; 之前几步已经分析，最后请求的数据会赋值给userResponse，最后获取的时候直接返回userResponse。 19.HttpEngine.java123456public void releaseConnection() throws IOException &#123; if (transport != null &amp;&amp; connection != null) &#123; transport.releaseConnectionOnIdle(); &#125; connection = null;&#125; 20.FramedTransport.java12@Override public void releaseConnectionOnIdle() &#123;&#125; 因为http2.0每个连接默认复用，所以不需要释放。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp详解4]]></title>
    <url>%2F2016%2F01%2F13%2Fokhttp%E8%AF%A6%E8%A7%A3(4).html</url>
    <content type="text"><![CDATA[接下来分析Transport中HttpTransport部分，主要分析数据发送和数据接收流程。 一、重要的类简述1.HttpTransport包装版的数据请求通道，包含httpConnection成员变量，所有的数据操作都是通过httpConnection操作。 2.HttpConnection数据操作，包含souce和sink两个成员变量，由socket包装而成。HttpConnection操作数据通过source和sink处理。 二、流程分析1.HttpTransport.java123456public void writeRequestHeaders(Request request) throws IOException &#123; httpEngine.writingRequestHeaders(); String requestLine = RequestLine.get( request, httpEngine.getConnection().getRoute().getProxy().type()); httpConnection.writeRequest(request.headers(), requestLine);&#125; http请求由三部分组成，分别是：请求行、消息报头、请求正文。首先创建请求行，然后通过httpConnection发送请求头和请求行。 2.HttpConnection.java12345678910111213/** Returns bytes of a request header for sending on an HTTP transport. */public void writeRequest(Headers headers, String requestLine) throws IOException &#123; if (state != STATE_IDLE) throw new IllegalStateException("state: " + state); sink.writeUtf8(requestLine).writeUtf8("\r\n"); for (int i = 0, size = headers.size(); i &lt; size; i ++) &#123; sink.writeUtf8(headers.name(i)) .writeUtf8(": ") .writeUtf8(headers.value(i)) .writeUtf8("\r\n"); &#125; sink.writeUtf8("\r\n"); state = STATE_OPEN_REQUEST_BODY;&#125; 这个部分很简单，就是按照http协议格式发送数据。 HttpTransport.java 1234567891011121314@Override public Sink createRequestBody(Request request, long contentLength) throws IOException &#123; if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) &#123; // Stream a request body of unknown length. return httpConnection.newChunkedSink(); &#125; if (contentLength != -1) &#123; // Stream a request body of a known length. return httpConnection.newFixedLengthSink(contentLength); &#125; throw new IllegalStateException( "Cannot stream a request body without chunked encoding or a known content length!"); &#125; 获取Request body Sink 4.HttpTransport.java123@Override public void finishRequest() throws IOException &#123; httpConnection.flush();&#125; 5.HttpTransport.java123public void flush() throws IOException &#123; sink.flush();&#125; 以上两部的目的是将之前写入sink的请求行、消息报头、请求正文发送出去。 6.HttpTransport.java123@Override public Response.Builder readResponseHeaders() throws IOException &#123; return httpConnection.readResponse();&#125; 7.HttpTransport.java12345678910111213141516171819202122232425262728public Response.Builder readResponse() throws IOException &#123; if (state != STATE_OPEN_REQUEST_BODY &amp;&amp; state != STATE_READ_RESPONSE_HEADERS) &#123; throw new IllegalStateException("state: " + state); &#125; try &#123; while (true) &#123; StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict()); Response.Builder responseBuilder = new Response.Builder() .protocol(statusLine.protocol) .code(statusLine.code) .message(statusLine.message); Headers.Builder headersBuilder = new Headers.Builder(); readHeaders(headersBuilder); headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString()); responseBuilder.headers(headersBuilder.build()); if (statusLine.code != HTTP_CONTINUE) &#123; state = STATE_OPEN_RESPONSE_BODY; return responseBuilder; &#125; &#125; &#125; catch (EOFException e) &#123; ... &#125;&#125; 读取响应头。 8.HttpTransport.java1234@Override public ResponseBody openResponseBody(Response response) throws IOException &#123; Source source = getTransferStream(response); return new RealResponseBody(response.headers(), Okio.buffer(source));&#125; 获取响应正文的数据。 getTransferStream这一步很关键，获取的是HttpConnection中的一个内部类Source。 9.HttpEngine.java1234public Response getResponse() &#123; if (userResponse == null) throw new IllegalStateException(); return userResponse;&#125; 之前几步已经分析，最后请求的数据会赋值给userResponse，最后获取的时候直接返回userResponse。 10.HttpEngine.java123456public void releaseConnection() throws IOException &#123; if (transport != null &amp;&amp; connection != null) &#123; transport.releaseConnectionOnIdle(); &#125; connection = null;&#125; 11.HttpTransport.java1234567@Override public void releaseConnectionOnIdle() throws IOException &#123; if (canReuseConnection()) &#123; httpConnection.poolOnIdle(); &#125; else &#123; httpConnection.closeOnIdle(); &#125;&#125; 释放资源，如果连接可重用则httpConnection.poolOnIdle()放置到连接池中，否则httpConnection.closeOnIdle()关闭连接。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp详解3]]></title>
    <url>%2F2016%2F01%2F13%2Fokhttp%E8%AF%A6%E8%A7%A3(3).html</url>
    <content type="text"><![CDATA[上一章分析了sendRequest部分，接下来分析readResponse部分，解决第二章中留下readResponse的问题，直接看代码。 1.HttpEngine.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void readResponse() throws IOException &#123; if (userResponse != null) &#123; return; // Already ready. &#125; if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; throw new IllegalStateException("call sendRequest() first!"); &#125; if (networkRequest == null) &#123; return; // No network response to read. &#125; Response networkResponse; if (forWebSocket) &#123; ... &#125; else if (!callerWritesRequestBody) &#123; networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest); &#125; else &#123; ... &#125; receiveHeaders(networkResponse.headers()); // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; if (validate(cacheResponse, networkResponse)) &#123; userResponse = cacheResponse.newBuilder() .request(userRequest) .priorResponse(stripBody(priorResponse)) .headers(combine(cacheResponse.headers(), networkResponse.headers())) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); releaseConnection(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). InternalCache responseCache = Internal.instance.internalCache(client); responseCache.trackConditionalCacheHit(); responseCache.update(cacheResponse, stripBody(userResponse)); userResponse = unzip(userResponse); return; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; userResponse = networkResponse.newBuilder() .request(userRequest) .priorResponse(stripBody(priorResponse)) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (hasBody(userResponse)) &#123; maybeCache(); userResponse = unzip(cacheWritingResponse(storeRequest, userResponse)); &#125; &#125; (1)判断userResponse是否被赋值。如果缓存存在并且未失效则在之前一章中sendRequest部分赋值。(2)forWebSocket为false，也是在HttpEngine实例化时候传递过来。将会走NetworkInterceptorChain(0, networkRequest).proceed(networkRequest)。(3)将获取的networkResponse赋值转化为userResponse(4)处理缓存和gzip解压 2.NetworkInterceptorChain.java12345678910111213141516171819202122232425262728293031323334@Override public Response proceed(Request request) throws IOException &#123; calls++; if (index &gt; 0) &#123; ... &#125; if (index &lt; client.networkInterceptors().size()) &#123; .... &#125; transport.writeRequestHeaders(request); //Update the networkRequest with the possibly updated interceptor request. networkRequest = request; if (permitsRequestBody(request) &amp;&amp; request.body() != null) &#123; Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; Response response = readNetworkResponse(); int code = response.code(); if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength()); &#125; return response; &#125; &#125; (1)发送请求头。transport在第一章之前说过，包括两种类型，http1.0对应HttpTransport，spdy/http2.0对应FrameTransport。(2)发送请求头。(2)将request body写入到Sink中。(3)读取Response。 3.HttpEngine.java123456789101112131415161718private Response readNetworkResponse() throws IOException &#123; transport.finishRequest(); Response networkResponse = transport.readResponseHeaders() .request(networkRequest) .handshake(connection.getHandshake()) .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis)) .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis())) .build(); if (!forWebSocket) &#123; networkResponse = networkResponse.newBuilder() .body(transport.openResponseBody(networkResponse)) .build(); &#125; return networkResponse; &#125; (1)首先是完成请求。作用是将上一步中request body Sink数据 发送出去。(2)创建networkResponse。 ###总结 将请求头和请求body发送出去。 从transport重获取ResponseHeaders。 从transport重获取ResponseBody。 接下来分析transport中的ResponseHeaders和ResponseBody是怎么获取的，因为transport包括两种类型，而且逻辑也比较多所以不放在本章分析。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp详解2]]></title>
    <url>%2F2016%2F01%2F11%2Fokhttp%E8%AF%A6%E8%A7%A3(2).html</url>
    <content type="text"><![CDATA[上一张分析了主体请求流程，接下来深入的分析流程中的细节，直接看代码。 1.HttpEngine.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void sendRequest() throws RequestException, RouteException, IOException &#123; if (cacheStrategy != null) return; // Already sent. if (transport != null) throw new IllegalStateException(); Request request = networkRequest(userRequest); InternalCache responseCache = Internal.instance.internalCache(client); Response cacheCandidate = responseCache != null ? responseCache.get(request) : null; long now = System.currentTimeMillis(); cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get(); networkRequest = cacheStrategy.networkRequest; cacheResponse = cacheStrategy.cacheResponse; if (responseCache != null) &#123; responseCache.trackResponse(cacheStrategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; if (networkRequest != null) &#123; // Open a connection unless we inherited one from a redirect. if (connection == null) &#123; connect(); &#125; transport = Internal.instance.newTransport(connection, this); //这里callerWritesRequestBody为false，在engine实例化的时候赋值 if (callerWritesRequestBody &amp;&amp; permitsRequestBody(networkRequest) &amp;&amp; requestBodyOut == null) &#123; .... &#125; &#125; else &#123; if (connection != null) &#123; Internal.instance.recycle(client.getConnectionPool(), connection); connection = null; &#125; if (cacheResponse != null) &#123; // We have a valid cached response. Promote it to the user response immediately. this.userResponse = cacheResponse.newBuilder() .request(userRequest) .priorResponse(stripBody(priorResponse)) .cacheResponse(stripBody(cacheResponse)) .build(); &#125; else &#123; // We're forbidden from using the network, and the cache is insufficient. this.userResponse = new Response.Builder() .request(userRequest) .priorResponse(stripBody(priorResponse)) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(EMPTY_BODY) .build(); &#125; userResponse = unzip(userResponse); &#125; &#125; (1)这里首先对request的head部分进行基础的配置。(2)获取本地缓存。（这一块也不做深入分析，有兴趣的可以深入了解，专门分析数据缓存，volley框架中也有比较清晰的逻辑）。(3)如果本地有缓存赋值给存储变量，如果没有缓存直接连接服务器。(4)创建transport。transport包括两种HttpTransport和FrameTransport。 2.HttpEngine.java123456789101112131415161718192021222324252627282930313233343536/** Connect to the origin server either directly or via a proxy. */private void connect() throws RequestException, RouteException &#123; if (connection != null) throw new IllegalStateException(); if (routeSelector == null) &#123; address = createAddress(client, networkRequest); try &#123; routeSelector = RouteSelector.get(address, networkRequest, client); &#125; catch (IOException e) &#123; throw new RequestException(e); &#125; &#125; connection = createNextConnection(); Internal.instance.connectAndSetOwner(client, connection, this); route = connection.getRoute();&#125; private Connection createNextConnection() throws RouteException &#123; ConnectionPool pool = client.getConnectionPool(); // Always prefer pooled connections over new connections. for (Connection pooled; (pooled = pool.get(address)) != null; ) &#123; if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) &#123; return pooled; &#125; closeQuietly(pooled.getSocket()); &#125; try &#123; Route route = routeSelector.next(); return new Connection(pool, route); &#125; catch (IOException e) &#123; throw new RouteException(e); &#125;&#125; (1)根据网络请求创建网络地址。(2)创建连接。首先从连接池总获取连接，如果没有连接则创建新的连接。 3.ConnectionPool.java12345678910111213141516171819202122232425262728293031/** Returns a recycled connection to &#123;@code address&#125;, or null if no such connection exists. */ public synchronized Connection get(Address address) &#123; Connection foundConnection = null; for (Iterator&lt;Connection&gt; i = connections.descendingIterator(); i.hasNext(); ) &#123; Connection connection = i.next(); if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() &gt;= keepAliveDurationNs) &#123; continue; &#125; i.remove(); if (!connection.isFramed()) &#123; try &#123; Platform.get().tagSocket(connection.getSocket()); &#125; catch (SocketException e) &#123; Util.closeQuietly(connection.getSocket()); // When unable to tag, skip recycling and close Platform.get().logW("Unable to tagSocket(): " + e); continue; &#125; &#125; foundConnection = connection; break; &#125; if (foundConnection != null &amp;&amp; foundConnection.isFramed()) &#123; connections.addFirst(foundConnection); // Add it back after iteration. &#125; return foundConnection; &#125; 从连接池中获取连接，判断条件包括地址、socket是否可用，闲置时间是否超时。对于FrameConnection直接重新到连接池中，对于HttpConnection则是请求完成后再添加到连接池中。 4.Connection.java12345678910111213141516171819/** * Connects this connection if it isn't already. This creates tunnels, shares * the connection with the connection pool, and configures timeouts. */ void connectAndSetOwner(OkHttpClient client, Object owner) throws RouteException &#123; setOwner(owner); if (!isConnected()) &#123; List&lt;ConnectionSpec&gt; connectionSpecs = route.address.getConnectionSpecs(); connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(), connectionSpecs, client.getRetryOnConnectionFailure()); if (isFramed()) &#123; client.getConnectionPool().share(this); &#125; client.routeDatabase().connected(getRoute()); &#125; setTimeouts(client.getReadTimeout(), client.getWriteTimeout()); &#125; (1)设置连接归属，只有对于HttpConnection才会设置。(2)如果是新创建的连接，则连接状态为false，则会开启连接，对于新创建的FrameConnection则会缓存。(3)如果是FrameConnection则放置的连接池中。 5.Connection.java1234567891011121314151617181920212223242526272829303132333435363738394041void connect(int connectTimeout, int readTimeout, int writeTimeout, List&lt;ConnectionSpec&gt; connectionSpecs, boolean connectionRetryEnabled) throws RouteException &#123; if (protocol != null) throw new IllegalStateException("already connected"); RouteException routeException = null; ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs); Proxy proxy = route.getProxy(); Address address = route.getAddress(); if (route.address.getSslSocketFactory() == null &amp;&amp; !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123; throw new RouteException(new UnknownServiceException( "CLEARTEXT communication not supported: " + connectionSpecs)); &#125; while (protocol == null) &#123; try &#123; socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy); connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector); &#125; catch (IOException e) &#123; Util.closeQuietly(socket); socket = null; handshake = null; protocol = null; httpConnection = null; framedConnection = null; if (routeException == null) &#123; routeException = new RouteException(e); &#125; else &#123; routeException.addConnectException(e); &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException; &#125; &#125; &#125; &#125; proxy.type()为Proxy.Type.HTTP，所以走 socket = address.getSocketFactory().createSocket()； 6.Connection.java123456789101112131415161718192021/** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout, ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; socket.setSoTimeout(readTimeout); Platform.get().connectSocket(socket, route.getSocketAddress(), connectTimeout); if (route.address.getSslSocketFactory() != null) &#123; connectTls(readTimeout, writeTimeout, connectionSpecSelector); &#125; else &#123; protocol = Protocol.HTTP_1_1; &#125; if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) &#123; socket.setSoTimeout(0); // Framed connection timeouts are set per-stream. framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket) .protocol(protocol).build(); framedConnection.sendConnectionPreface(); &#125; else &#123; httpConnection = new HttpConnection(pool, this, socket); &#125;&#125; (1)开启连接。Platform针对不同的平台进行适配，然后连接socket。(2)判断是否存在SslSocketFactory（也可以说是否是htts的地址）。因为http类型只支持HTTP_1_1， https支持http2.0/spdy/http1.1。(3)针对https类型连接Tls。主要的目的是获取服务器支持什么协议。(4)创建连接Connection（HttpConnection/FramedConnection） 7.Connection.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void connectTls(int readTimeout, int writeTimeout, ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; if (route.requiresTunnel()) &#123; createTunnel(readTimeout, writeTimeout); &#125; Address address = route.getAddress(); SSLSocketFactory sslSocketFactory = address.getSslSocketFactory(); boolean success = false; SSLSocket sslSocket = null; try &#123; // Create the wrapper over the connected socket. sslSocket = (SSLSocket) sslSocketFactory.createSocket( socket, address.getUriHost(), address.getUriPort(), true /* autoClose */); // Configure the socket's ciphers, TLS versions, and extensions. ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket); if (connectionSpec.supportsTlsExtensions()) &#123; Platform.get().configureTlsExtensions( sslSocket, address.getUriHost(), address.getProtocols()); &#125; // Force handshake. This can throw! sslSocket.startHandshake(); Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession()); ... // Check that the certificate pinner is satisfied by the certificates presented. address.getCertificatePinner().check(address.getUriHost(), unverifiedHandshake.peerCertificates()); // Success! Save the handshake and the ALPN protocol. String maybeProtocol = connectionSpec.supportsTlsExtensions() ? Platform.get().getSelectedProtocol(sslSocket) : null; socket = sslSocket; handshake = unverifiedHandshake; protocol = maybeProtocol != null ? Protocol.get(maybeProtocol) : Protocol.HTTP_1_1; success = true; &#125; catch (AssertionError e) &#123; ... &#125; finally &#123; ... &#125; &#125; 主要是通过tls握手获取服务器支持的协议和获取sslSocket。 ###总结 sendRequest部分分析完成，分析时候我思考几个问题 ：(1)Connection的连接复用http1.1 keep-alive和http2.0的连接复用有什么区别呢？(2)sendRequest的流程部分怎么没有发送请求和body的代码？ 2.由上述分析可知：(1)每个请求都会开启一个HttpEngine。(2)每个HttpEngine都会包含一个Connection。(新创建或者连接池中获取)(3)每个HttpEngine在会创建Transport(构造函数包括Connection)。Transport的作为读取数据和发送请求的一个桥梁，下一章中分析它的作用。(4)每个Connection包含一个FrameConnection或者HttpConnection，这两个对象才是真正的操作数据，也在下一章分析。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp详解1]]></title>
    <url>%2F2016%2F01%2F10%2Fokhttp%E8%AF%A6%E8%A7%A3(1).html</url>
    <content type="text"><![CDATA[okhttp是square推出的网络开源库，支持http语义缓存，支持spdy和http2.0协议。看源码的目的主要是了解http协议实现，最重要是了解okhhtp的优劣，http2.0/spdy协议多路复用技术，多路复用技术与keep—alive的区别。 接下来首先分析主体流程，直接看代码 （此版本是okhttp2.6） ， okhttp中包含okio库，okio是一个增强的io库， sink简单理解为OutputStream，source理解为InputStreame。 一、总体设计图 二、流程图 三、代码1.Call.java1234567891011121314public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; try &#123; client.getDispatcher().executed(this); Response result = getResponseWithInterceptorChain(false); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.getDispatcher().finished(this); &#125;&#125; 主要将请求存放到Dispatcher中，同步请求应该可以忽略这个部分。 2.ApplicationInterceptorChain.java12345678910111213141516171819@Override public Response proceed(Request request) throws IOException &#123; // If there's another interceptor in the chain, call that. if (index &lt; client.interceptors().size()) &#123; Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket); Interceptor interceptor = client.interceptors().get(index); Response interceptedResponse = interceptor.intercept(chain); if (interceptedResponse == null) &#123; throw new NullPointerException("application interceptor " + interceptor + " returned null"); &#125; return interceptedResponse; &#125; // No more interceptors. Do HTTP. return getResponse(request, forWebSocket); &#125; 这里判断是否有拦截器，如果有拦截器则交给拦截器处理，拦截器的作用就是调试（Facebook stetho）。如果没有拦截器则直接处理。 3.Call.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Response getResponse(Request request, boolean forWebSocket) throws IOException &#123; // Copy body metadata to the appropriate request headers. RequestBody body = request.body(); if (body != null) &#123; Request.Builder requestBuilder = request.newBuilder(); MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header("Content-Type", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header("Content-Length", Long.toString(contentLength)); requestBuilder.removeHeader("Transfer-Encoding"); &#125; else &#123; requestBuilder.header("Transfer-Encoding", "chunked"); requestBuilder.removeHeader("Content-Length"); &#125; request = requestBuilder.build(); &#125; // Create the initial HTTP engine. Retries and redirects need new engine for each attempt. engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null); int followUpCount = 0; while (true) &#123; if (canceled) &#123; engine.releaseConnection(); throw new IOException("Canceled"); &#125; try &#123; engine.sendRequest(); engine.readResponse(); &#125; catch (RequestException e) &#123; // The attempt to interpret the request failed. Give up. throw e.getCause(); &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. HttpEngine retryEngine = engine.recover(e); if (retryEngine != null) &#123; engine = retryEngine; continue; &#125; // Give up; recovery is not possible. throw e.getLastConnectException(); &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. HttpEngine retryEngine = engine.recover(e, null); if (retryEngine != null) &#123; engine = retryEngine; continue; &#125; // Give up; recovery is not possible. throw e; &#125; Response response = engine.getResponse(); Request followUp = engine.followUpRequest(); if (followUp == null) &#123; if (!forWebSocket) &#123; engine.releaseConnection(); &#125; return response; &#125; if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; throw new ProtocolException("Too many follow-up requests: " + followUpCount); &#125; if (!engine.sameConnection(followUp.httpUrl())) &#123; engine.releaseConnection(); &#125; Connection connection = engine.close(); request = followUp; engine = new HttpEngine(client, request, false, false, forWebSocket, connection, null, null, response); &#125; &#125; 这里是数据请求的核心流程，包括发送请求、读取数据和异常重试（重试机制不做了解）。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015->2016总结和展望]]></title>
    <url>%2F2016%2F01%2F01%2F2015%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C2016%E7%9A%84%E5%B1%95%E6%9C%9B.html</url>
    <content type="text"><![CDATA[一、2015 总结稳定，沉淀的一年。基本完成2015的计划。 成果 参与稳定的项目开发，更加严格的开发流程。 深入的学习了java和android方面的知识。 业余时间独立完成Github客户端。 深入了解了Android系统组件的运行流程。 老罗的博客。 参与优秀开源项目的解析以及pr。 阅读了一些专业技术的书籍 《深入理解android》《android内核剖析》《android性能优化》。 简单的阅读okhtt源码（下一步深入） 不足 一直觉得进步不是很大。 运动少。 二. 2016 展望 更加深入的学习android底层的知识， linux方面的知识。 积极参加github开源项目的一些活动， 积极更新博客。 精读优秀开源作品相关源码。 主要了解网络模块的知识。 沉淀知识]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide 源码解析]]></title>
    <url>%2F2015%2F10%2F25%2FGlide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[在泰国举行的谷歌开发者论坛上，谷歌为我们介绍了一个名叫 Glide 的图片加载库，作者是bumptech。这个库被广泛的运用在google的开源项目中，包括2014年google I/O大会上发布的官方app。Glide和Picasso使用上有90%的相似度，但是内部实现机制有很大区别 Glide介绍。 1.主要特点(1)支持Memory和Disk图片缓存。(2)支持gif和webp格式图片。(3)根据Activity/Fragment生命周期自动管理请求。(4)使用Bitmap Pool可以使Bitmap复用。(5)对于回收的Bitmap会主动调用recycle，减小系统回收压力。 2. 总体设计 基本概念RequestManager：请求管理，每一个Activity都会创建一个RequestManager，根据对应Activity的生命周期管理该Activity上所以的图片请求。 Engine：加载图片的引擎，根据Request创建EngineJob和DecodeJob。 EngineJob：图片加载。 DecodeJob：图片处理。 流程图这里是大概的总体流程图， 具体的细节中流程下面继续分析。 3. 核心类介绍3.1 Gilde用于保存整个框架中的配置。 重要方法：1234public static RequestManager with(FragmentActivity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125; 用于创建RequestManager，这里是Glide通过Activity/Fragment生命周期管理Request原理所在，这个类很关键、很关键、很关键，重要的事情我只说三遍。主要原理是创建一个自定义Fragment，然后通过自定义Fragment生命周期操作RequestManager，从而达到管理Request。 3.2 RequestManagerRetriever123456789RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123; SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager;&#125; 这里判断是否只当前RequestManagerFragment是否存在RequestManager，保证一个Activity对应一个RequestManager， 这样有利于管理一个Activity上所有的Request。创建RequestManager的时候会将RequestManagerFragment中的回调接口赋值给RequestManager，达到RequestManager监听RequestManagerFragment的生命周期。 3.3 RequestManager成员变量：(1)Lifecycle lifecycle,用于监听RequestManagerFragment生命周期。(2)RequestTracker requestTracker, 用于保存当前RequestManager所有的请求和带处理的请求。 重要方法：12345678910111213141516171819202122232425262728293031323334@Override//开始暂停的请求public void onStart() &#123; resumeRequests();&#125;//停止所有的请求@Overridepublic void onStop() &#123; pauseRequests();&#125;//关闭所以的请求@Overridepublic void onDestroy() &#123; requestTracker.clearRequests();&#125;//创建RequestBuildpublic DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125;public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123; ... Request previous = target.getRequest(); //停止当前target中的Request。 if (previous != null) &#123; previous.clear(); //这个地方很关键，见Request解析 requestTracker.removeRequest(previous); previous.recycle(); &#125; ... return target;&#125; 3.4 DrawableRequestBuilder用于创建Request。 这里面包括很多方法，主要是配置加载图片的url、大小、动画、ImageView对象、自定义图片处理接口等。 3.5 Request主要是操作请求，方法都很简单。123456789@Overridepublic void clear() &#123; ... if (resource != null) &#123; //这里会释放资源 releaseResource(resource); &#125; ...&#125; 这里的基本原理是当有Target使用Resource（Resource见下文）时，Resource中的引用记数值会加一，当释放资源Resource中的引用记数值减一。当没有Target使用的时候就会释放资源，放进Lrucache中。 3.7 EngineResource实现Resource接口，使用装饰模式，里面包含实际的Resource对象123456789101112131415void release() &#123; if (--acquired == 0) &#123; listener.onResourceReleased(key, this); &#125;&#125; void acquire() &#123; ++acquired;&#125; @Overridepublic void recycle() &#123; isRecycled = true; resource.recycle();&#125; acquire和release两个方法是对资源引用计数；recycle释放资源，一般在Lrucache饱和时会触发。 3.8 Engine（重要）请求引擎，主要做请求的开始的初始化。 3.8.1 load方法这个方法很长，将分为几步分析 (1)获取MemoryCache中缓存首先创建当前Request的缓存key，通过key值从MemoryCache中获取缓存，判断缓存是否存在。123456789101112131415161718 private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; .... EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); if (cached != null) &#123; cached.acquire(); activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue())); &#125; return cached;&#125;@SuppressWarnings("unchecked")private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123; Resource&lt;?&gt; cached = cache.remove(key); final EngineResource result; ... return result;&#125; （重点）从缓存中获取的时候使用的cache.remove(key),然后将值保存在activeResources中，然后将Resource的引用计数加一。优点： 正使用的Resource将会在activeResources中，不会出现在cache中，当BitmapPool中缓存饱和的时候或者系统内存不足的时候，清理Bitmap可以直接调用recycle,不用考虑Bitmap正在使用导致异常，加快系统的回收。 (2)获取activeResources中缓存activeResources通过弱引用保存recouse ，也是通过key获取缓存， 1private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) (3)判断当前的请求任务是否已经存在12345EngineJob current = jobs.get(key);if (current != null) &#123; current.addCallback(cb); return new LoadStatus(cb, current);&#125; 如果任务请求已经存在，直接将回调事件传递给已经存在的EngineJob，用于请求成功后触发回调。 (4)执行请求任务1234567EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority);EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);jobs.put(key, engineJob);engineJob.addCallback(cb);engineJob.start(runnable); 3.9 EngineRunnable请求执行Runnable，主要功能请求资源、处理资源、缓存资源。12345678910111213141516171819 private Resource&lt;?&gt; decodeFromCache() throws Exception &#123; Resource&lt;?&gt; result = null; try &#123; result = decodeJob.decodeResultFromCache(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Exception decoding result from cache: " + e); &#125; &#125; if (result == null) &#123; result = decodeJob.decodeSourceFromCache(); &#125; return result;&#125; private Resource&lt;?&gt; decodeFromSource() throws Exception &#123; return decodeJob.decodeFromSource();&#125; 加载DiskCache和网络资源。加载DiskCache包括两个，因为Glide默认是保存处理后的资源（压缩和裁剪后），缓存方式可以自定义配置。如果客户端规范设计，ImageView大小大部分相同可以节省图片加载时间和Disk资源。 3.10 DecodeJob123public Resource&lt;Z&gt; decodeResultFromCache() throws Exception public Resource&lt;Z&gt; decodeSourceFromCache() throws Exception 从缓存中获取处理后的资源。上面有关Key的内容，Key是一个对象，可以获取key和orginKey。decodeResultFromCache就是通过key获取缓存，decodeSourceFromCache()就是通过orginKey获取缓存。 1private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) 处理和包装资源；缓存资源。 1234//保存原资源private Resource&lt;T&gt; cacheAndDecodeSourceData(A data) throws IOException //保存处理后的资源private void writeTransformedToCache(Resource&lt;T&gt; transformed) 3.11 Transformation1Resource&lt;T&gt; transform(Resource&lt;T&gt; resource, int outWidth, int outHeight); 处理资源，这里面会从BitmapPool中获取缓存Bitmap，如果有的话直接将缓存的Bitmap当成画布，如果达到Bitmap复用， 对于处理前的资源直接回收到 BitmapPool中。 3.12 ResourceDecoder用于将文件、IO流转化为Resource 3.13BitmapPool用于存放从LruCache中remove的Bitmap， 用于后面创建Bitmap时候的重复利用。 4.杂谈Glide的架构扩展性高，但是难以理解，各种接口、泛型，需要一定的学习才能熟练运用。 Glide的优点： (1)支持对处理后的资源DiskCache。(2)支持inBitmap高级特性（详情Google）。(3)使用巧妙的设计：使用BitmapPool减少内存抖动;通过弱引用activityResources缓存正在使用的resource，而不是在MemoryCache，在内存不足的时候，MemoryCache中的图片会移除到itmapPool中，对于BitmapPool饱和移除的Bitmap可以直接调用recycle。]]></content>
      <categories>
        <category>图片加载</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片两级缓存解析]]></title>
    <url>%2F2015%2F10%2F16%2F%E5%9B%BE%E7%89%87%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[图片加载是客户端开发中重要的一个模块，如今也有很多优秀的开源库(UIL、Picasso、Glide、Fresco)。大部分图片库都采用了Memory缓存和Disk缓存。 1. Memory缓存（LruCache）最直接的方法就是看源码 1.1 成员变量12345 private final LinkedHashMap&lt;K, V&gt; map;/** Size of this cache in units. Not necessarily the number of elements. */private int size;private int maxSize; map用于存放缓存的Bitmapsize当前缓存的总大小maxSize是缓存允许的最大大小，由构造函数赋值。 1.2 重要方法1.2.1 添加数据12345678910111213141516171819 public final V put(K key, V value) &#123; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous;&#125; (1) 首先计算存入的数据大小。(2) 添加数据的大小。(3) 保存到map中。(4) 如果之前key保存的数据存在减去之前数据占用的大小。(5) 检查缓存。 1.2.2 检查缓存123456789101112131415161718192021222324252627282930private void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; if (size &lt;= maxSize) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125;&#125; 循环判断当前缓存大小是否超过最大值，如果超过清除使用。 LinkedHashMap提供特殊的构造方法来创建链接哈希映射，该哈希映射的迭代顺序就是最后访问其条目的顺序，从近期访问最少到近期访问最多的顺序（访问顺序）。这种映射很适合构建 LRU 缓存， 这里不做深入解释。所以第一条数据是很久没使用的数据，即为删除的数据。将缓存大小减去删除数据的大小。 1.2.3 获取数据1234567891011121314151617 public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125;.... &#125; 2. Disk缓存（DiskLruCache）2.1 成员变量 12345678910111213//保存缓存文件的文件夹 private final File directory; //保存缓存文件系统信息的文件。private final File journalFile;private final File journalFileTmp;private final int appVersion;private final long maxSize;private final int valueCount;private long size = 0;private Writer journalWriter; //用于保存缓存文件信息，初始化由journalFile解析赋值。private final LinkedHashMap&lt;String, Entry&gt; lruEntries = new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true); 2.2 重要方法 12345678910111213141516171819202122232425262728293031public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException &#123; DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); if (cache.journalFile.exists()) &#123; try &#123; cache.readJournal(); cache.processJournal(); cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true), IO_BUFFER_SIZE); return cache; &#125; catch (IOException journalIsCorrupt) &#123;// System.logW("DiskLruCache " + directory + " is corrupt: "// + journalIsCorrupt.getMessage() + ", removing"); cache.delete(); &#125; &#125; directory.mkdirs(); cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); cache.rebuildJournal(); return cache;&#125;private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) &#123; this.directory = directory; this.appVersion = appVersion; this.journalFile = new File(directory, JOURNAL_FILE); this.journalFileTmp = new File(directory, JOURNAL_FILE_TMP); this.valueCount = valueCount; this.maxSize = maxSize;&#125; (1)创建DiskLruCache实例对象。(2)判断文件系统中是否存在缓存系统信息的文件。(3)根据不同的情况分别初始化 首先了解 ： DIRTY这个字样都不代表着什么好事情，意味着这是一条脏数据。没错，每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。1234567891011121314151617181920212223private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // snapshot is stale &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; else if (entry.currentEditor != null) &#123; return null; // another edit is in progress &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; // flush the journal before creating files to prevent file leaks journalWriter.write(DIRTY + ' ' + key + '\n'); journalWriter.flush(); return editor;&#125; 从缓存系统获取编辑器，然后想缓存信息文件中添加记录数据。 然后从Edit中获取OutputStream，从而网文件系统中写文件。12345678 public OutputStream newOutputStream(int index) throws IOException &#123; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; return new FaultHidingOutputStream(new FileOutputStream(entry.getDirtyFile(index))); &#125;&#125; 当文件写完以后成功则调用Edit.commit(),失败则调用Edit.abort()12345678910111213141516 public void commit() throws IOException &#123; if (hasErrors) &#123; completeEdit(this, false); remove(entry.key); // the previous entry is stale &#125; else &#123; completeEdit(this, true); &#125;&#125;/** * Aborts this edit. This releases the edit lock so another edit may be * started on the same key. */public void abort() throws IOException &#123; completeEdit(this, false);&#125; 继续看最重要的保存数据方法1234567891011121314151617181920212223242526272829303132333435363738private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; .... for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.getDirtyFile(i); if (success) &#123; if (dirty.exists()) &#123; File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; deleteIfExists(dirty); &#125; &#125; redundantOpCount++; entry.currentEditor = null; if (entry.readable | success) &#123; entry.readable = true; journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n'); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; lruEntries.remove(entry.key); journalWriter.write(REMOVE + ' ' + entry.key + '\n'); &#125; if (size &gt; maxSize || journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; &#125; 如果成功将DirtyFile转化为CleanFile，然后添加文件描述。如果失败则删除DirtyFile，然后添加文件描述。最后检查缓存大小，清理缓存系统。 123456789101112131415161718192021222324252627282930public synchronized Snapshot get(String key) throws IOException &#123; checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null) &#123; return null; &#125; if (!entry.readable) &#123; return null; &#125; InputStream[] ins = new InputStream[valueCount]; try &#123; for (int i = 0; i &lt; valueCount; i++) &#123; ins[i] = new FileInputStream(entry.getCleanFile(i)); &#125; &#125; catch (FileNotFoundException e) &#123; // a file must have been deleted manually! return null; &#125; redundantOpCount++; journalWriter.append(READ + ' ' + key + '\n'); if (journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; return new Snapshot(key, entry.sequenceNumber, ins);&#125; 每当我们调用get()方法去读取一条缓存数据时，就会向journal文件中写入一条READ记录。因为每次读取都会向journal文件中写入一条READ记录，所以也需要检查缓存。 123456789101112131415private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;Void&gt;() &#123; @Override public Void call() throws Exception &#123; synchronized (DiskLruCache.this) &#123; if (journalWriter == null) &#123; return null; // closed &#125; trimToSize(); if (journalRebuildRequired()) &#123; rebuildJournal(); redundantOpCount = 0; &#125; &#125; return null; &#125;&#125;; 缓存清理任务。首先清理缓存文件，然后重新生成journal文件。]]></content>
      <categories>
        <category>图片加载</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存回收]]></title>
    <url>%2F2015%2F10%2F15%2FJVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6.html</url>
    <content type="text"><![CDATA[1.判断对象是否存活1.1引用计数法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加2；当引用失效时，计数器值减1。但是这种计算方法很难解决对象互相循环引用的问题。 1.2 根搜索算法通过一系列的GC Roots对象作为起始点，通过这个节点向下搜索，如果一个对象没有一条从GC Roots到该对象的路径，则不可达，即可被回收。 1.3 引用强引用：永远不会被回收的引用对象 Object o = new Object()软引用：在OOM之前会把这些对象作为垃圾对象进行回收，如果还没有足够的内存，则OOM，通过SoftReference类来实现弱引用： 存活到下一次垃圾收集发生之前WeakReference实现虚引用：最弱的，唯一目的是在对象被回收时收到一个系统通知。 PlantomReference实现。 当一个对象要被回收时需要进行两次标记，经历两次标记后的对象才会被回收，第一次就是GC roots不可达的的，第二次是调用finalize()后还没被拯救的。 2. 垃圾收集算法2.1 标记-清除标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。标记—清除算法的执行情况如下图所示： 该算法有如下缺点：标记和清除过程的效率都不高。标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。 2.2 复制算法它将内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。复制算法有如下优点：每次只对一块内存进行回收，运行高效。只需移动栈顶指针，按顺序分配内存即可，实现简单。内存回收时不用考虑内存碎片的出现。它的缺点是：可一次性分配的最大内存缩小了一半。对新生代的回收采用此方法，一般不是采用1：1的比例，而是将其化为y一个 Eden和2个Survivor区，Eden：Survivor为8：1 ，每次只使用Eden区和1个Survivor，将活着的放到剩下的Survivor区中。复制算法的执行情况如下图所示： 2.3 标记-整理复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。标记—整理算法的回收情况如下所示： 2.4 分代收集当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。 3 垃圾回收器在java虚拟机中，没有最好的垃圾收集器，只有适合的垃圾收集，所以垃圾收集通过多种垃圾收集器合作完成。 3.1 Serial收集器新生代垃圾收集器，单一线程，垃圾收集时Stop The World，复制算法。 3.2 Serial Old收集器老年代垃圾收集器，单一线程，垃圾收集时Stop The World，标记整体算法。 两种Serial收集器工作流程图： 3.3 ParNew收集器新生代垃圾收集器，多线程，垃圾收集时Stop The World，复制算法。 3.3 ParNew Old收集器老年代垃圾收集器，多线程，垃圾收集时Stop The World，标记整体算法。 3.4 Parallel Scanvenge 收集器新生代收集器，复制算法，多线程执行，垃圾收集时Stop The World，关注吞吐量（用户代码时间/虚拟机运行总时间）。高吞吐量可以高效的利用Cpu时间，尽快的完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 3.5 CMS收集算法老年代收集器，标记-清除算法，关注最短收集停顿时间。分为四个步骤：初始标记，并发标记，重新标记，并发清除。初始标记、重新标记两个步骤Stop The World，其余步骤都是可以和用户线程并发进行。 缺点：对CPU资源敏感。无法处理浮动垃圾。产生空间碎片。 3.6 G1收集器标记整理算法，精确的控制停顿时间。G1强整个Java堆划分为多个固定的独立却与，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。 4. 内存分配和回收策略4.1对象优先分配在Eden大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配吗虚拟机则发起一次young gc。 4.2 大对象直接进入老年代需要大量连续的内存空间的Java对象，比如长字符串和数组。目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝。 4.3 长期存活的对象进入老年代每一个对象都有一个对象年龄计数器。如果对象在Eden出生并经过第一次young gc后仍然存活，并且能被Survivor容纳，将被移动到Survivor区，并将对象年龄设为1。对象在Survivor区没熬过一次young gc年龄增加一岁，当年龄增加到一定的程度将会移动到老年代中。 4.4 动态对象年龄判断如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的所有对象就可以直接进入老年代。 4.5 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存模型]]></title>
    <url>%2F2015%2F10%2F14%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[1.内存区域Java虚拟机在执行Java程序的过程中会把管理的内存分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。 1.1.程序计数器当前线程执行字节码的行号指示器，通过改变计数器的值选取下一条执行的字节码指令，线程切换后恢复到正确的执行位置，跳转、循环等都依赖计算器来完成。每个线程都需要一个独立的程序计数器。唯一不会出现OOM的区域，为每个线程私有的。当执行的是Native方法时计数器的值为空。 1.2.Java虚拟机栈Java虚拟机栈的生命周期与线程一样，每个方法被执行的时候会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法调用到执行完成的过程对应一个帧栈找虚拟机栈中入栈到入栈的过程。局部变量表存放各种基本数据类型、对象引用，局部变量表所需的内存空间在编译器完成分配。当所请求的栈的深度大于所允许的最大深度时会出现stackoverflow异常，当扩展无法申请足够的内存时，会抛出OOM。 1.3.本地方法栈和虚拟机栈十分相似，只不过里面是以本地方法服务的。所以也会发生stackoverflow和OOM。 1.4.Java堆一般来说Java堆是Java虚拟机管理的内存中最大的一块。Java堆是所有线程共享的内存区域，所有的对象实例已经数组都在堆上分配，但是随着JIT编译器的发展，并不是那么绝对了。Java堆分为新生代和老年代，不同区域的垃圾回收处理不同。 1.5.方法区方法区是线程共享的内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 1.6. 运行常量池是方法区的一部分。Class文件中一项信息是常量池，用于存放编译期间生成的各种字面量和符号引用。这部分内容在类加载后进入方法区的运行时常量池中存放。 1.7. 直接内存并不是虚拟机运行时数据区的一部分，也不是JAVA虚拟机规范中定义的内存区域，但是这部分区域被频繁使用，同时也会出现OOM。NIO中，引入了一种基于通道和缓冲区的IO方式，使用Native库直接分配堆外内存，然后通过一个存储在JAVA堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能用显著提升性能，避免了在Java堆和Native堆中来回复制数据。直接内存不会受到JAVA堆大小的限制，会受到本机中内存的限制。 2. 对象访问存在两种方式：(1).通过句柄的方式，会在堆中单独划出一块内存当做句柄池。 (2).reference直接存储对象地址。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP详解笔记]]></title>
    <url>%2F2015%2F10%2F12%2FTCP-IP%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[TCP/IP协议是新版的网络协议，包括4层结构。 1.层次结构TCP/IP协议分为四层：1) 链路层， 有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。2) 网络层，有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在T C P / I P协议族中，网络层协议包括 I P协议（网际协议） ，I C M P协议（I n t e r n e t互联网控制报文协议） ，以及I G M P协议（I n t e r n e t组管理协议） 。3 ) 运输层主要为两台主机上的应用程序提供端到端的通信。在 T C P / I P协议族中，有两个互不相同的传输协议：T C P（传输控制协议）和U D P（用户数据报协议） 。T C P为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。而另一方面，U D P则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。这两种运输层协议分别在不同的应用程序中有不同的用途，这一点将在后面看到。4 ) 应用层负责处理特定的应用程序细节。 封装： 2.链路层链路层主要有三个目的：（1）为I P模块发送和接收I P数据报；（2）为A R P模块发送A R P请求和接收A R P应答；（3）为R A R P发送R A R P请求和接收R A R P应答。 3.IPI P是T C P / I P协议族中最为核心的协议。所有的 T C P、U D P、I C M P及I G M P数据都以I P数据报格式传输。IP协议头： IP路由选择：当一个IP数据包准备好了的时候，IP数据包是如何将数据包送到目的地的呢？它是怎么选择一个合适的路径来”送货”的呢？最特殊的情况是目的主机和主机直连，那么主机根本不用寻找路由，直接把数据传递过去就可以了。至于是怎么直接传递的，这就要靠ARP协议了，后面会讲到。稍微一般一点的情况是，主机通过若干个路由器(router)和目的主机连接。那么路由器就要通过ip包的信息来为ip包寻找到一个合适的目标来进行传递，比如合适的主机，或者合适的路由。路由器或者主机将会用如下的方式来处理某一个IP数据包。(1)如果IP数据包的TTL（生命周期）以到，则该IP数据包就被抛弃。(2)搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机。(3)搜索路由表，如果匹配主机失败，则匹配同子网的路由器。如果找到路由器，则将该包发向路由器。(4)搜索路由表，如果匹配同子网路由器失败，则匹配同网号路由器，如果找到路由器，则将该包发向路由器。(5)搜索路由表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包。(6)如果都失败了，就丢掉这个包。 ARP协议：ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自 己的ARP高速缓存（就是一个IP-MAC地址对应表缓存），如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包 里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包 含自己的MAC地址的ARP包传送给发送ARP广播的主机，而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送 广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。 4.UDPU D P是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个 U D P数据报，并组装成一份待发送的 I P数据报。U D P不提供可靠性：它把应用程序传给 I P层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，我们似乎觉得要避免使用 U D P而使用一种可靠协议如 T C P。 5.TCP5.1建立连接协议（三次握手）（1）客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的报文1。（2） 服务器端回应客户端的，这是三次握手中的第2个报文，这个报文同时带ACK标志和SYN标志。因此它表示对刚才客户端SYN报文的回应；同时又标志SYN给客户端，询问客户端是否准备好进行数据通讯。（3） 客户必须再次回应服务段一个ACK报文。5.2连接终止协议（四次挥手）由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1）。和SYN一样，一个FIN将占用一个序号。（3） 服务器关闭客户端的连接，发送一个FIN给客户端。（4） 客户段发回ACK报文确认，并将确认序号设置为收到序号加1。 5.3 TCP超时重传T C P提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。 T C P通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。 5.4 保持鲜活许多T C P / I P的初学者会很惊奇地发现可以没有任何数据流通过一个空闲的 T C P连接。也就是说，如果T C P连接的双方都没有向对方发送数据， 则在两个T C P模块之间不交换任何信息。例如，没有可以在其他网络协议中发现的轮询。这意味着我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码解析]]></title>
    <url>%2F2015%2F09%2F15%2FRetrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[Retrofit是Android端网络请求框架，支持标准的HTTP协议。简单易用，代码量少。比较有意思的是Retrofit主要原理是动态代理和反射，感觉这种想法比较新颖。本文分析的版本是Retrofit1.9.0（2.0.+有挺多变化的）。阅读之前请了解Java动态代理。推荐Java动态代理。 1 Retrofit特点(1)支持数据反序列化和反序列化借口配置。(2)支持网络数据接口自定义配置。 2 类分析2.1 RestAdapter.java123456789101112131415161718192021//方法解析信息Map，保存每个方法的信息避免每一次都需要解析方法，节省时间。private final Map&lt;Class&lt;?&gt;, Map&lt;Method, RestMethodInfo&gt;&gt; serviceMethodInfoCache = new LinkedHashMap&lt;Class&lt;?&gt;, Map&lt;Method, RestMethodInfo&gt;&gt;();//保存请求接口的urlfinal Endpoint server;//网络数据交互Executorfinal Executor httpExecutor;//完成数据回调Executorfinal Executor callbackExecutor;//请求拦截处理final RequestInterceptor requestInterceptor;//数据序列化和反序列化工具final Converter converter;final Log log;final ErrorHandler errorHandler;//网络请求Providerprivate final Client.Provider clientProvider;private final Profiler profiler;//这个是联合RxJava使用private RxSupport rxSupport; 通过接口创建代理对象12345public &lt;T&gt; T create(Class&lt;T&gt; service) &#123; Utils.validateServiceClass(service); return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new RestHandler(getMethodInfoCache(service))); &#125; 2.2 RestHandler.java1234567//在这个方法内解析方法、根据方法走不同的请求方式。//分为三种模式：返回值类型是自定义Bean类型;返回类型是void，需要处理回调;还有一种是RxJava(暂不了解-_-)public Object invoke(Object proxy, Method method, final Object[] args) //请求网络数据，反序列数据private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo, Object[] args) 2.3 RestMethodInfo.java记录每个方法的信息1234567891011121314//返回值类型final ResponseType responseType;final boolean isSynchronous; //是有返回值类型final boolean isObservable; //是RxJava中的Observable类型Type responseObjectType;RequestType requestType = RequestType.SIMPLE;String requestMethod;boolean requestHasBody;String requestUrl; //请求接口的uriSet&lt;String&gt; requestUrlParamNames;String requestQuery;List&lt;retrofit.client.Header&gt; headers;String contentTypeHeader;boolean isStreaming; 12//解析方法信息private void parseMethodAnnotations() 2.4 Converter.java12345//网络数据反序列化Object fromBody(TypedInput body, Type type) throws ConversionException;//请求数据格式化TypedOutput toBody(Object object); 2.5 Request.java12345private final String method;private final String url;private final List&lt;Header&gt; headers;//请求参数bodyprivate final TypedOutput body; 3 比较VolleyVolley解析 、 网络框架比较相同点：(1)都支持标准的HTTP协议。不同点(1)Volley内置支持图片加载；Retrofit不支持。(2)Volley对多种HTTP返回码进行处理；Retrofit也处理了基本的的返回码，但没有Volldey详细。(3)Volly中Request自定义设置重试机制；Retrofit不支持。(4)Volley不支持大数据文件请求；Retrofit支持。(5)Volley内置支持数据缓存和304返回码处理；Retrofit默认不支持缓存，但可以搭配okhttp实现数据缓存和304返回码处理。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Picasso源码解析]]></title>
    <url>%2F2015%2F09%2F11%2FPicasso%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[1 功能介绍Picasso是square推出的一个Android平台的图片加载开源库。包含内存缓存和磁盘缓存两级缓存。可定制度高、自定义配置、提供接口自定义处理图片等。在 Adapter 中自动处理 ImageView 的缓存并且取消之前的图片下载任务。 2.总体设计 ###3 详细设计 3.1 加载流程图及类图流程图： 类图: 3.2 核心类分析3.2.1 Picasso.Builder这是一个通过Build创建Picasso的工具类。 3.2.2 Picasso.javaPicasso保存了所有请求的配置1234567891011121314151617181920212223private final Listener listener;private final RequestTransformer requestTransformer;private final CleanupThread cleanupThread;private final List&lt;RequestHandler&gt; requestHandlers;final Context context;final Dispatcher dispatcher;final Cache cache;final Stats stats;final Map&lt;Object, Action&gt; targetToAction;final Map&lt;ImageView, DeferredRequestCreator&gt; targetToDeferredRequestCreator;final ReferenceQueue&lt;Object&gt; referenceQueue;final Bitmap.Config defaultBitmapConfig;Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) //如果没有初始化，使用默认初始化Picasso public static Picasso with(Context context) //创建RequestCreator public RequestCreator load(...) 这里会检查当前ImageView是否已经存在加载任务，如果存在直接取消任务，开始新的任务。//这样防止了ListView中的ImageView复用问题。123456789void enqueueAndSubmit(Action action) &#123;Object target = action.getTarget();if (target != null &amp;&amp; targetToAction.get(target) != action) &#123; // This will also check we are on the main thread. cancelExistingRequest(target); targetToAction.put(target, action);&#125;submit(action);&#125; 3.2.3 Downloader.java图片下载客户端。默认为OkHttpDownloader,okhttp存在DiskLruCache数据缓存，如果使用其他的下载客户端(HttpURLConnection、HttpClient)需要自己定义数据本地缓存。1Response load(Uri uri, int networkPolicy) throws IOException; 3.2.4 Cache.java运行内存图片缓存。默认使用的缓存是LruCache，基本原理就是向缓存中添加图片，计算图片的大小，计算缓存所有图片的总大小，如果总图片的大小超过设定的大小，就删除使用频率低的图片。12345//从缓存中获取图片Bitmap get(String key); //向缓存中添加图片void set(String key, Bitmap bitmap) 3.2.5 Dispatcher.java请求分发和请求接口回调。通过命名可以清晰的知道其含义。123456789101112131415void dispatchSubmit(Action action) void dispatchCancel(Action action)void dispatchPauseTag(Object tag)void dispatchResumeTag(Object tag)void dispatchComplete(BitmapHunter hunter)void dispatchRetry(BitmapHunter hunter)void dispatchFailed(BitmapHunter hunter)void dispatchNetworkStateChange(NetworkInfo info) 12345678910111213141516171819202122232425262728void performSubmit(Action action, boolean dismissFailed) &#123; if (pausedTags.contains(action.getTag())) &#123; pausedActions.put(action.getTarget(), action); return; &#125; BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) &#123; hunter.attach(action); return; &#125; if (service.isShutdown()) &#123; return; &#125; hunter = forRequest(action.getPicasso(), this, cache, stats, action); hunter.future = service.submit(hunter); hunterMap.put(action.getKey(), hunter); if (dismissFailed) &#123; failedActions.remove(action.getTarget()); &#125; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId()); &#125;&#125; (1) 判断当前tag的请求是已经暂停，如果已经暂停添加到暂停队列中。(2) BitmapHunter其实实现Runnable，是图片请求任务，判断图片资源的请求是否存在，如果存在将action保存到BitmapHunter中，等图片请求完成后一起处理。(3)创建BitmapHunter，请求图片，保存到hunterMap中。 12345678910void performComplete(BitmapHunter hunter) &#123;if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123; cache.set(hunter.getKey(), hunter.getResult());&#125;hunterMap.remove(hunter.getKey());batch(hunter);if (hunter.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), "for completion");&#125;&#125; 请求完成以后将结果添加到缓存中，hunterMap清除当前hunter。 3.2.6 RequestHandler.java请求处理。包括网络请求，本地文件请求等。默认有6个实现类：ContactsPhotoRequestHandler(context);MediaStoreRequestHandler(context);ContentStreamRequestHandler(context);AssetRequestHandler(context);FileRequestHandler(context);NetworkRequestHandler(dispatcher.downloader, stats); 123456789101112131415161718192021static void calculateInSampleSize(int reqWidth, int reqHeight, int width, int height, BitmapFactory.Options options, Request request) &#123;int sampleSize = 1;if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int heightRatio; final int widthRatio; if (reqHeight == 0) &#123; sampleSize = (int) Math.floor((float) width / (float) reqWidth); &#125; else if (reqWidth == 0) &#123; sampleSize = (int) Math.floor((float) height / (float) reqHeight); &#125; else &#123; heightRatio = (int) Math.floor((float) height / (float) reqHeight); widthRatio = (int) Math.floor((float) width / (float) reqWidth); sampleSize = request.centerInside ? Math.max(heightRatio, widthRatio) : Math.min(heightRatio, widthRatio); &#125;&#125;options.inSampleSize = sampleSize;options.inJustDecodeBounds = false;&#125; 基本的图片压缩算法，算出压缩比，通过BitmapFactory压缩图片，但是这样的压缩不够全面，只有整数倍压缩，所以压缩过后还需要进行二次压缩，后面将出现二次压缩的算法。 1234//获取图片资源，将数据保存在Result中。public abstract Result load(Request request, int networkPolicy) throws IOException;//根据Request，判断当前RequestHandler是否可以处理。public abstract boolean canHandleRequest(Request data); 3.2.7 RequestCreator.java12//下面方法中设置都会赋值在data中，然后根据data中配置的值创建图片请求private final Request.Builder data; 图片压缩完成以后，取中间的那一块，如下图。1public RequestCreator centerCrop() 图片会按设置的尺寸，根据宽高比例压缩。与centerCrop不能同时使用1public RequestCreator centerInside() 根据ImageView的大小设置图片压缩的大小1public RequestCreator fit() 直接设置图片压缩的大小，与fit不可同时使用1public RequestCreator resize 设置压缩后的图片自定义处理接口1public RequestCreator transform(Transformation transformation) 设置请求前的图片1public RequestCreator placeholder() 设置请求错误的图片1public RequestCreator error() 将图片显示在设置的View上面1234//直接给ImageView设置bitmap， 也会使用回调Callback，但是没用传递数据。public void into(ImageView target, Callback callback)//Target 相当于一个CallBack，当图片请求成功以后，将Bitmap回调。public void into(Target target) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void into(ImageView target, Callback callback) &#123;long started = System.nanoTime();if (deferred) &#123; if (data.hasSize()) &#123; throw new IllegalStateException("Fit cannot be used with resize."); &#125; int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height);&#125;Request request = createRequest(started);String requestKey = createKey(request);if (shouldReadFromMemoryCache(memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125;&#125; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable());&#125;Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade);picasso.enqueueAndSubmit(action);&#125; (1)deferred表示自动获取ImageView的大小，但是由于ImageView设置wrap_content的时候是获取不到ImageView的大小，所以添加到延迟加载的队列中，当ImageView显示到屏幕以后会开启任务。如果xml中固定了ImageView的大小直接将大小获取，保存起来。(2)创建Request，根据Request获取缓存数据的key，判断缓存是否存在，存在直接返回。(3)如果缓存不存在，创建ImageViewAction，提交Action加载图片。 3.2.8 Action.java12345final Picasso picasso;final Request request;final WeakReference&lt;T&gt; target;final String key;final Object tag; 3.2.9 BitmapHunter.javaBitmap请求Runnable12345678910111213141516171819202122232425@Override public void run() &#123; try &#123; updateThreadName(data); result = hunt(); if (result == null) &#123; dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; &#125; catch (Downloader.ResponseException e) &#123; dispatcher.dispatchFailed(this); &#125; catch (NetworkRequestHandler.ContentLengthException e) &#123; dispatcher.dispatchRetry(this); &#125; catch (IOException e) &#123; dispatcher.dispatchRetry(this); &#125; catch (OutOfMemoryError e) &#123; StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); &#125; catch (Exception e) &#123; dispatcher.dispatchFailed(this); &#125; finally &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Bitmap hunt() throws IOException &#123; Bitmap bitmap = null; if (shouldReadFromMemoryCache(memoryPolicy)) &#123; bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); loadedFrom = MEMORY; return bitmap; &#125; &#125; data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy; RequestHandler.Result result = requestHandler.load(data, networkPolicy); if (result != null) &#123; loadedFrom = result.getLoadedFrom(); exifRotation = result.getExifOrientation(); bitmap = result.getBitmap(); // If there was no Bitmap then we need to decode it from the stream. if (bitmap == null) &#123; InputStream is = result.getStream(); try &#123; bitmap = decodeStream(is, data); &#125; finally &#123; Utils.closeQuietly(is); &#125; &#125; &#125; if (bitmap != null) &#123; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; stats.dispatchBitmapDecoded(bitmap); if (data.needsTransformation() || exifRotation != 0) &#123; synchronized (DECODE_LOCK) &#123; if (data.needsMatrixTransform() || exifRotation != 0) &#123; bitmap = transformResult(data, bitmap, exifRotation); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId()); &#125; &#125; if (data.hasCustomTransformations()) &#123; bitmap = applyCustomTransformations(data.transformations, bitmap); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), "from custom transformations"); &#125; &#125; &#125; if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; &#125; &#125; return bitmap;&#125; 这个方法是处理图片最核心的方法，包括请求图片、压缩图片、处理图片。(1)首先还是会校验内存缓存中是否已经存在。(2)requestHandler很重要，是请求图片的工具类，看forRequest这个方法，首先获取所有的RequestHandler， 之前有说过默认五种RequestHandler，然后获取可以处理请求的RequestHandler。(3)生成压缩后的bitmap (整数倍)。(4)处理图片的转向，小数倍压缩。(5)自定义图片处理。(6)分发结果 12345678//生成BitmapHunter。static BitmapHunter forRequest();//压缩图片static Bitmap decodeStream(InputStream stream, Request request) throws IOException；//压缩和处理图片static Bitmap transformResult(Request data, Bitmap result, int exifRotation) 3.杂谈]]></content>
      <categories>
        <category>图片加载</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView优化]]></title>
    <url>%2F2015%2F09%2F05%2FListView%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[在Android程序中，列表是一个很重要的部分，在看法中我们需要关心ListView的各方面的效率。最近也一直在思考这些问题，刚好看到Facebook的ListView优化，所以借鉴Facebook的方案将自己项目中的部分模块优化。请参考Fast Rendering News Feed on Android 、facebook新闻页ListView优化。 1.基本知识1.1 首先使用ViewHolder和ItemViewType优化ListView。1.2 合理的任务调度。1.3 降低ItemView的复杂度（嵌套层次） 2.Facebook优化方案。使用基本的优化方案可以保证简单的ListView保持流畅，但是对于ListView中Item类型过多，基本的优化方案会导致ViewItem复用率低。 2.1 将每个Item拆分为多个Item。将Item上部分和下部分相同的模块提取出来作为一个Item，即每一个Item分成多个Item，使得多个Item可以达到复用，提高复用率。 数据处理也需要将每个Item拆分为多个Item123456789101112131415161718192021222324 public static FeedWrap feed2ItemTop(Feed feed) &#123; if (feed == null) return null; return new FeedWrap(FeedItem.HEAD, feed.getFeedId(), new FeedHead(feed.getSenderName(), feed.getFeedTime(), feed.getSenderImg())); &#125; public static FeedWrap feed2ItemButtom(Feed feed) &#123; if (feed == null) return null; return new FeedWrap(FeedItem.BUTTOM, feed.getFeedId(), new FeedButtom(feed.getIsPraiseByMe(), feed.getRelpyNum(), feed.getForwardNum(), feed.getPraiseNum())); &#125;public static FeedWrap feed2ConTent(Feed feed) &#123;&#125;public static List&lt;FeedWrap&gt; feed2ConTent(List&lt;Feed&gt; feeds) &#123; if (feeds == null) return null; ArrayList&lt;FeedWrap&gt; feedWraps = new ArrayList&lt;&gt;(); for (Feed feed : feeds) &#123; feedWraps.add(feed2ItemTop(feed)); feedWraps.add(feed2ConTent(feed)); feedWraps.add(feed2ItemButtom(feed)); &#125; return feedWraps; &#125; 2.2 预处理数据数据格式化，创建spannable。 比如Json数据的反序列化12345678910111213141516171819202122232425262728public static FeedWrap feed2Wrap(Feed feed) &#123; if (feed == null) return null; FeedContent feedContent = null; switch (feed.getFeedType()) &#123; case TEXT: feedContent = GsonUtil.getGson().fromJson(feed.getFeedContent(), FeedContentText.class); return new FeedWrap(FeedItem.Content.TEXT, feed.getFeedId(), feedContent); case IMAGE: feedContent = GsonUtil.getGson().fromJson(feed.getFeedContent(), FeedContentImage.class); return new FeedWrap(FeedItem.Content.IMAGE, feed.getFeedId(), feedContent); case VIDEO: feedContent = GsonUtil.getGson().fromJson(feed.getFeedContent(), FeedContentVideo.class); return new FeedWrap(FeedItem.Content.VIDEO, feed.getFeedId(), feedContent); case REPOST: feedContent = GsonUtil.getGson().fromJson(feed.getFeedContent(), FeedContentRepost.class); return new FeedWrap(FeedItem.Content.REPOST, feed.getFeedId(), feedContent); case NEWS: feedContent = GsonUtil.getGson().fromJson(feed.getFeedContent(), FeedContentNews.class); return new FeedWrap(FeedItem.Content.NEWS, feed.getFeedId(), feedContent); default: return new FeedWrap(FeedItem.Content.UNKNOW, feed.getFeedId(), null); &#125;&#125; 2.3 显示数据FaceBook的方案是将没个Item做成一个自定义的View，方便管理，在demo中为了节省时间省略。12345678910111213141516171819202122232425262728293031private View getViewByViewType(int itemViewType, ViewGroup viewGroup) &#123; View view = null; Holder holder = null; switch (itemViewType) &#123; case FeedItem.HEAD: view = mInflater.inflate(R.layout.feed_item_head, viewGroup, false); holder = new HeadViewHolder(view); break; case FeedItem.BUTTOM: view = mInflater.inflate(R.layout.feed_item_bottom, viewGroup, false); holder = new ButtomViewHolder(view); break; case FeedItem.Content.TEXT: view = mInflater.inflate(R.layout.feed_item_text, viewGroup, false); holder = new TextViewHolder(view); break; case FeedItem.Content.VIDEO: view = mInflater.inflate(R.layout.feed_item_video, viewGroup, false); holder = new VideoViewHolder(view); break; default: view = mInflater.inflate(R.layout.feed_item_unknow, viewGroup, false); break; &#125; view.setTag(holder); return view;&#125; 2.4 操作数据之前数据分为多个Item和显示数据较为简单， 但是在操作数据中就会遇到问题，我分为了两种方案。第一种方案在删除数据时非常安全，但是每次删除会遍历集合，效率方面存在问题；第二种方案根据自己的实际情况，直接通过position删除数据，但这种删除数据给人一种存在隐患。1234567891011121314151617181920212223242526public void remove(FeedWrap feedWrap) &#123; if (feedWrap!= null &amp;&amp; mFeedWraps != null) &#123; Iterator&lt;FeedWrap&gt; feedWrapIterator = mFeedWraps.iterator(); while (feedWrapIterator.hasNext()) &#123; FeedWrap tempFeedWrap = feedWrapIterator.next(); if (tempFeedWrap.getFeedId() == feedWrap.getFeedId()) &#123; feedWrapIterator.remove(); &#125; &#125; &#125;&#125;/** * 特殊情况， 根据删除按钮的item position 来确定其他同一条动态的其他item * 这种效率高，但感觉有危险,自己根据自己的情况而定 * @param position */public boolean remove(FeedWrap feedWrap, int position) &#123; if (checkRemoveData(feedWrap, position)) &#123; mFeedWraps.remove(position); mFeedWraps.remove(position); mFeedWraps.remove(position); return true; &#125; return false;&#125; 在Item点击的时候，默认ListView的Item有selector效果，但是分为多个Item以后，selector效果会导致Item分块， 看起来不是一个整体， 可以在ListView中设置属性selector为透明。1android:listSelector="#00000000" 3. 对Facebook方案疑惑的地方。因为对Facebook方案存在疑惑，所以我没有使用Binder和PartDefinition。3.1 It is called before the first time a binder is bound, and intelligently scheduled when there’s free CPU time on the UI thread.This makes it ideal for allocating click listeners, formatting strings, building spannables and so forth。 在Binder的prepare中进行click事件绑定，而prepare是在cpu闲时主线程中调用的（那就肯定不是getView中调用了），那就没有View， 我也不知道他是怎么绑定click事件的。所以我感觉prepare只是做一些数据的预处理操作。click应该在bind中设置。 Demo源码]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ListView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View绘制流程]]></title>
    <url>%2F2015%2F08%2F22%2FView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[在Activity显示到界面流程的最后一步ViewRoot.setView中有个requestLayout方法，这个方法其实就是请求绘制view。 1 View绘制的整体流程1.1 ViewRoot.requestLayout123456789101112131415161718public void requestLayout() &#123; checkThread(); mLayoutRequested = true; scheduleTraversals();&#125; public void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; sendEmptyMessage(DO_TRAVERSAL); &#125;&#125; case DO_TRAVERSAL: performTraversals(); break; 1.2 ViewRoot.performTraversals123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public final class ViewRoot extends Handler implements ViewParent, View.AttachInfo.Callbacks &#123; ...... View mView; ...... boolean mLayoutRequested; boolean mFirst; ...... boolean mFullRedrawNeeded; ...... private final Surface mSurface = new Surface(); ...... private void performTraversals() &#123; ...... final View host = mView; if (mFirst) &#123; fullRedrawNeeded = true; mLayoutRequested = true; DisplayMetrics packageMetrics = mView.getContext().getResources().getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; attachInfo.mSurface = mSurface; attachInfo.mUse32BitDrawingCache = PixelFormat.formatHasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888; attachInfo.mHasWindowFocus = false; attachInfo.mWindowVisibility = viewVisibility; attachInfo.mRecomputeGlobalAttributes = false; attachInfo.mKeepScreenOn = false; viewVisibilityChanged = false; mLastConfiguration.setTo(host.getResources().getConfiguration()); host.dispatchAttachedToWindow(attachInfo, 0); &#125;else &#123; desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123; if (DEBUG_ORIENTATION) Log.v(TAG, "View " + host + " resized to: " + frame); fullRedrawNeeded = true; mLayoutRequested = true; windowResizesToFitContent = true; &#125; &#125; ...... mTraversalScheduled = false; ...... boolean fullRedrawNeeded = mFullRedrawNeeded; boolean newSurface = false; ...... if (mLayoutRequested) &#123; ...... host.measure(childWidthMeasureSpec, childHeightMeasureSpec); ....... &#125; ...... int relayoutResult = 0; if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null) &#123; ...... boolean hadSurface = mSurface.isValid(); try &#123; ...... relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... if (!hadSurface) &#123; if (mSurface.isValid()) &#123; ...... newSurface = true; fullRedrawNeeded = true; ...... &#125; &#125; ...... &#125; catch (RemoteException e) &#123; &#125; ...... &#125; final boolean didLayout = mLayoutRequested; ...... if (didLayout) &#123; mLayoutRequested = false; ...... host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight); ...... &#125; ...... mFirst = false; ...... boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw(); if (!cancelDraw &amp;&amp; !newSurface) &#123; mFullRedrawNeeded = false; draw(fullRedrawNeeded); ...... &#125; else &#123; ...... // Try again scheduleTraversals(); &#125; &#125; ...... &#125; 1)如果是第一次进行View遍历，则对mAttachInfo变量初始化，然后调用host.dispatchAttachedToWindow传递给每一个View，这样View中可以通过这个变量调用重新绘制。2）如果不是第一次看是否布局大小有没有变化，有则将fullRedrawNeeded、mLayoutRequested、windowResizesToFitContent赋值为true。fullRedrawNeeded代表要全部重新绘制，mLayoutRequested重新指定视图位置。3）如果要重新布局（mLayoutRequested为true），要重新layout必须重新mesure，所以需要重新计算视图大小host.measure。4）当视图大小变化或者视图visible发生变化都需要请求WindowManagerSerivce重新分配窗口大小。5）如果需要重新布局调用host.layout6）如果不中断draw则调用draw方法，否则重新调用一次performTraversals流程。 2.View的mesure流程2.1 View.mesure1234567891011121314151617181920212223242526272829public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; if ((mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~MEASURED_DIMENSION_SET; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_MEASURE); &#125; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException("onMeasure() did not set the" + " measured dimension by calling" + " setMeasuredDimension()"); &#125; mPrivateFlags |= LAYOUT_REQUIRED; &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec;&#125; 1）View.mesure 是一个final方法，子类不可以重写，所以子类只能重写onMeasure。widthMeasureSpec和heightMeasureSpec对应的是视图允许的最大宽和高，measureSpec是int类型，该值有高32位和低16位组成，高32位代表的specMode，低16为表示的是specSize。2）specMode有三种类型。MeasureSpec.UNSPECIFIED大小不确定，根据自身大小确定的，也就是WRAP_CONTENT;MeasureSpec.AT_MOST占有父布局最大的大小，也就是MATCH_PARENT;MeasureSpec.EXACTLY大小确定，比如直接写100dp。3）specSize就是确定父View能给的最大大小的值。4)ViewRoot类的成员变量mPrivateFlags的类型为int，如果它的某一个位的值不等于0，那么就隐含着当前视图有一个相应的操作在等待执行中。ViewRoot类的另外两个成员变量mOldWidthMeasureSpec和mOldHeightMeasureSpec用来保存当前视图上一次可以获得的最大宽度和高度。当ViewRoot类的成员变量mPrivateFlags的FORCE_LAYOUT位不等于0时，就表示当前视图正在请求执行一次布局操作，这时候函数就需要重新测量当前视图的宽度和高度。此外，当参数widthMeasureSpec和heightMeasureSpec的值不等于ViewRoot类的成员变量mldWidthMeasureSpec和mOldHeightMeasureSpec的值时，就表示当前视图上一次可以获得的最大宽度和高度已经失效了，这时候函数也需要重新测量当前视图的宽度和高度。 2.2 FrameLayout.onMeasure1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; final int count = getChildCount(); int maxHeight = 0; int maxWidth = 0; // Find rightmost and bottommost child for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); maxWidth = Math.max(maxWidth, child.getMeasuredWidth()); maxHeight = Math.max(maxHeight, child.getMeasuredHeight()); &#125; &#125; // Account for padding too maxWidth += mPaddingLeft + mPaddingRight + mForegroundPaddingLeft + mForegroundPaddingRight; maxHeight += mPaddingTop + mPaddingBottom + mForegroundPaddingTop + mForegroundPaddingBottom; // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) &#123; maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); &#125; setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), resolveSize(maxHeight, heightMeasureSpec));&#125; 1)首先调用measureChildWithMargins计算子View的大小。2）用maxWidth和maxHeight计算子View需要的总大小。3） 然后保存当前View的大。 2.3 View.measureChildWithMargins12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 这里是测量子View的大小，根据父View和子View的大小和属性，确定子View的大小，然后调用child.mesure方法。 2.4 View.setMeasuredDimension123456789101112131415161718192021222324public static int resolveSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: result = Math.min(size, specSize); break; case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125;protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= MEASURED_DIMENSION_SET;&#125; 确定自己的大小值记录在mMeasuredWidth和mMeasuredHeight中。 3 View的Layout过程3.1 View.layout123456789101112public final void layout(int l, int t, int r, int b) &#123; boolean changed = setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT); &#125; onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~LAYOUT_REQUIRED; &#125; mPrivateFlags &amp;= ~FORCE_LAYOUT;&#125; 3.2 View.setFrame123456789101112131415161718192021222324252627282930313233343536373839404142protected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; // Remember our drawn bit int drawn = mPrivateFlags &amp; DRAWN; // Invalidate our old position invalidate(); int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; mLeft = left; mTop = top; mRight = right; mBottom = bottom; mPrivateFlags |= HAS_BOUNDS; int newWidth = right - left; int newHeight = bottom - top; if (newWidth != oldWidth || newHeight != oldHeight) &#123; onSizeChanged(newWidth, newHeight, oldWidth, oldHeight); &#125; if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123; mPrivateFlags |= DRAWN; invalidate(); &#125; // Reset drawn bit to original value (invalidate turns it off) mPrivateFlags |= drawn; mBackgroundSizeChanged = true; &#125; return changed;&#125; 当View的大小发生变化的时候才会重新设置大小 3.312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; final int count = getChildCount(); final int parentLeft = mPaddingLeft + mForegroundPaddingLeft; final int parentRight = right - left - mPaddingRight - mForegroundPaddingRight; final int parentTop = mPaddingTop + mForegroundPaddingTop; final int parentBottom = bottom - top - mPaddingBottom - mForegroundPaddingBottom; mForegroundBoundsChanged = true; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft = parentLeft; int childTop = parentTop; final int gravity = lp.gravity; if (gravity != -1) &#123; final int horizontalGravity = gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK; final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (horizontalGravity) &#123; case Gravity.LEFT: childLeft = parentLeft + lp.leftMargin; break; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = parentRight - width - lp.rightMargin; break; default: childLeft = parentLeft + lp.leftMargin; &#125; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; FrameLayout类的成员变量mPaddingLeft、mPaddingRight、mPaddingTop、mPaddingBottom和mForegroundPaddingLeft、mForegroundPaddingRight、mForegroundPaddingTop、mForegroundPaddingBottom的含义我们在前面分析Android应用程序窗品的测量过程时已经解释过了，它们描述的是当前视图的内边距，而参数left、top、right和bottom描述的是当前视图的外边距，即它与父窗口的边距。通过上述这些参数，我们就可以得到当前视图的子视图所能布局在的区域。FrameLayout类的成员函数onLayout通过一个for循环来布局当前视图的每一个子视图。如果一个子视图child是可见的，那么FrameLayout类的成员函数onLayout就会根据当前视图可以用来显示子视图的区域以及它所设置的gravity属性来得到它在应用程序窗口中的左上角位置（childeLeft，childTop）。当一个子视图child在应用程序窗口中的左上角位置确定了之后，再结合它在前面的测量过程中所确定的宽度width和高度height，我们就可以完全地确定它在应用程序窗口中的布局了，即可以调用它的成员函数layout来设置它的位置和大小了。 4. View.draw 过程4.1 ViewRoot.draw这一步更多的是底层的东西，准备画布 4.2DecorView.draw1234567public void draw(Canvas canvas) &#123; super.draw(canvas); if (mMenuBackground != null) &#123; mMenuBackground.draw(canvas); &#125;&#125; DecorView类的成员函数draw首先调用父类FrameLayout的成员函数draw来绘制它的UI内容，然后再检查它是否设置了菜单背景，即成员变量mMenuBackground的值是否不等于null。如果不等于null的话，那么就会调用它所指向的一个Drawable对象的成员函数draw来在画布canvas上绘制这个菜单背景。 4.2 View.draw调用dispatchDraw 4.3 ViewGroup. dispatchDraw遍历子view，调用子view.draw 特别推荐，将的非常详细。Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析View 绘制流程]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>View绘制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Touch事件分发]]></title>
    <url>%2F2015%2F08%2F20%2FTouch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html</url>
    <content type="text"><![CDATA[之前分析了界面显示流程，显示以后，界面将接收用户操作事件，本文将分析Touch事件分发机制。 1. 由Activity显示到界面流程分析中我们知道最后创建ViewRoot，ViewRoot的setView中注册了事件消息处理。具体的注册流程和事件回调请看老罗消息处理机制分析123456789101112131415161718192021222324252627282930313233343536373839404142public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; mWindowAttributes.copyFrom(attrs); attrs = mWindowAttributes; mSoftInputMode = attrs.softInputMode; mWindowAttributesChanged = true; mAttachInfo.mRootView = view; mAttachInfo.mScalingRequired = mTranslator != null; mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale; if (panelParentView != null) &#123; mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken(); &#125; requestLayout(); mInputChannel = new InputChannel(); try &#123; res = sWindowSession.add(mWindow, mWindowAttributes, getHostVisibility(), mAttachInfo.mContentInsets, mInputChannel); &#125; catch (RemoteException e) &#123; &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; if (mInputQueueCallback != null) &#123; &#125; else &#123; InputQueue.registerInputChannel(mInputChannel, mInputHandler, Looper.myQueue()); &#125; &#125; &#125;&#125; InputQueue.registerInputChannel(mInputChannel, mInputHandler,Looper.myQueue())，注册接收mInputHandler。 2. new InputHandler()1234567891011private final InputHandler mInputHandler = new InputHandler() &#123; public void handleKey(KeyEvent event, Runnable finishedCallback) &#123; startInputEvent(finishedCallback); dispatchKey(event, true); &#125; public void handleMotion(MotionEvent event, Runnable finishedCallback) &#123; startInputEvent(finishedCallback); dispatchMotion(event, true); &#125;&#125;; 3. ViewRoot.dispatchMotion1234567891011121314private void dispatchMotion(MotionEvent event, boolean sendDone) &#123; int source = event.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; dispatchPointer(event, sendDone); &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; dispatchTrackball(event, sendDone); &#125; else &#123; // TODO Log.v(TAG, "Dropping unsupported motion event (unimplemented): " + event); if (sendDone) &#123; finishInputEvent(); &#125; &#125;&#125; 4. ViewRoot.dispatchPointer123456private void dispatchPointer(MotionEvent event, boolean sendDone) &#123; Message msg = obtainMessage(DISPATCH_POINTER); msg.obj = event; msg.arg1 = sendDone ? 1 : 0; sendMessageAtTime(msg, event.getEventTime());&#125; ViewRoot本身是Handler对象。 5. ViewRoot.handleMessage12345678910111213141516@Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case DISPATCH_POINTER: &#123; MotionEvent event = (MotionEvent) msg.obj; try &#123; deliverPointerEvent(event); &#125; finally &#123; event.recycle(); if (msg.arg1 != 0) &#123; finishInputEvent(); &#125; if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG, "Done dispatching!"); &#125; &#125; break;&#125; 6. ViewRoot.deliverPointerEvent1234567891011121314151617181920212223242526272829303132private void deliverPointerEvent(MotionEvent event) &#123; if (mTranslator != null) &#123; mTranslator.translateEventInScreenToAppWindow(event); &#125; boolean handled; if (mView != null &amp;&amp; mAdded) &#123; ... handled = mView.dispatchTouchEvent(event); if (MEASURE_LATENCY) &#123; lt.sample("B Dispatched TouchEvents ", System.nanoTime() - event.getEventTimeNano()); &#125; if (!handled &amp;&amp; isDown) &#123; int edgeSlop = mViewConfiguration.getScaledEdgeSlop(); .... if (edgeFlags != 0 &amp;&amp; mView instanceof ViewGroup) &#123; View nearest = FocusFinder.getInstance().findNearestTouchable( ((ViewGroup) mView), x, y, direction, deltas); if (nearest != null) &#123; event.offsetLocation(deltas[0], deltas[1]); event.setEdgeFlags(0); mView.dispatchTouchEvent(event); &#125; &#125; &#125; &#125;&#125;这里mView在setView的方法中初始化，其实就是Window中的DecorView。 7. DecorView.dispatchTouchEvent12345678910111213public boolean dispatchKeyEvent(KeyEvent event) &#123; final int keyCode = event.getKeyCode(); final boolean isDown = event.getAction() == KeyEvent.ACTION_DOWN; final Callback cb = getCallback(); final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event); if (handled) &#123; return true; &#125; return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event) : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);&#125; 这里的callback就是在activity的attach方法中设置的，其实就是Activity。 8. Activity.dispatchTouchEvent123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 9. PhoneWindow.superDispatchTouchEvent1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 10. DecorView.superDispatchTouchEvent123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 11. ViewGroup.dispatchTouchEvent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (!onFilterTouchEventForSecurity(ev)) &#123; return false; &#125; final int action = ev.getAction(); final float xf = ev.getX(); final float yf = ev.getY(); final float scrolledXFloat = xf + mScrollX; final float scrolledYFloat = yf + mScrollY; final Rect frame = mTempRect; boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (action == MotionEvent.ACTION_DOWN) &#123; if (mMotionTarget != null) &#123; // this is weird, we got a pen down, but we thought it was // already down! // XXX: We should probably send an ACTION_UP to the current // target. mMotionTarget = null; &#125; // If we're disallowing intercept or if we're allowing and we didn't // intercept if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; // reset this event's action (just to protect ourselves) ev.setAction(MotionEvent.ACTION_DOWN); // We know we want to dispatch the event down, find a child // who can handle it, start with the front-most child. final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); if (frame.contains(scrolledXInt, scrolledYInt)) &#123; // offset the event to the view's coordinate system final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; if (child.dispatchTouchEvent(ev)) &#123; // Event handled, we have a target now. mMotionTarget = child; return true; &#125; // The event didn't get handled, try the next view. // Don't reset the event's location, it's not // necessary here. &#125; &#125; &#125; &#125; &#125; boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; // Note, we've already copied the previous state to our local // variable, so this takes effect on the next event mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // The event wasn't an ACTION_DOWN, dispatch it to our target if // we have one. final View target = mMotionTarget; if (target == null) &#123; // We don't have a target, this means we're handling the // event as a regular view. ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; return super.dispatchTouchEvent(ev); &#125; // if have a target, see if we're allowed to and want to intercept its // events if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123; final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; ev.setAction(MotionEvent.ACTION_CANCEL); ev.setLocation(xc, yc); if (!target.dispatchTouchEvent(ev)) &#123; // target didn't handle ACTION_CANCEL. not much we can do // but they should have. &#125; // clear the target mMotionTarget = null; // Don't dispatch this event to our own view, because we already // saw it when intercepting; we just want to give the following // event to the normal onTouchEvent(). return true; &#125; if (isUpOrCancel) &#123; mMotionTarget = null; &#125; // finally offset the event to the target's coordinate system and // dispatch the event. final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setLocation(xc, yc); if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; mMotionTarget = null; &#125; return target.dispatchTouchEvent(ev);&#125; 1）首先判断disallowIntercept，只有ViewGroup才可以中断touch事件传递。2）onInterceptTouchEvent开发者自定义是否中断事件传递，默认为false。3）for循环遍历子View，然后调用子View的dispatchTouchEvent，如果有子View消费事件使用mMotionTarget记录当前的子View。4）这里可以看出，只有Down的时候消费了事件才可以接收接下来的事件。5）如果没有子View消费事件或者ViewGroup中断事件传递则调用super.dispatchTouchEvent(ev)，则是View.dispatchTouchEvent(ev)。 12. View.dispatchTouchEvent1234567891011public boolean dispatchTouchEvent(MotionEvent event) &#123; if (!onFilterTouchEventForSecurity(event)) &#123; return false; &#125; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event);&#125; 这里如果设置自定义的mOnTouchListener，然后消费事件则直接返回true，否则调用onTouchEvent 13 View.onTouchEvent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; &#125; break; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_CANCEL: break; case MotionEvent.ACTION_MOVE: break; &#125; return true; &#125; return false;&#125; 如果View是CLICKABLE，直接消费事件（Button就是CLICKABLE） touch消息处理流程图]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity显示到界面流程]]></title>
    <url>%2F2015%2F08%2F15%2FActivity%E6%98%BE%E7%A4%BA%E5%88%B0%E7%95%8C%E9%9D%A2%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[之前分析过Activity的启动流程，虽然Activity启动了，但是显示在界面上的并不是Activity，接下来将分析Activity显示到界面的流程。 首先看看各个相关类的关系图 1.Activity.attach在Activity启动流程的35步中，我们可以看到Activity的实例化，然后调用Activity.attach初始化所有的数据。12345678910111213141516171819202122232425262728293031323334353637final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance, HashMap&lt;String,Object&gt; lastNonConfigurationChildInstances, Configuration config) &#123; attachBaseContext(context); mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstance = lastNonConfigurationInstance; mLastNonConfigurationChildInstances = lastNonConfigurationChildInstances; mWindow.setWindowManager(null, mToken, mComponent.flattenToString()); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config;&#125; 里面实际就是初始化一些值，新建了一个window对象。 2. PolicyManager.makeNewWindow123456789101112public static Window makeNewWindow(Context context) &#123; return sPolicy.makeNewWindow(context);&#125;public PhoneWindow makeNewWindow(Context context) &#123; return new PhoneWindow(context); &#125; public PhoneWindow(Context context) &#123; super(context); mLayoutInflater = LayoutInflater.from(context);&#125; 3. PhoneWindow.setCallback这个很重要，后面接受键盘和触屏时间都是回调 Window.CallBack,所以Activity能接受到键盘和触屏事件 4. Window.setWindowManager123456789public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123; mAppToken = appToken; mAppName = appName; if (wm == null) &#123; wm = WindowManagerImpl.getDefault(); &#125; mWindowManager = new LocalWindowManager(wm);&#125; 5. WindowManagerImpl.getDefault123456private static WindowManagerImpl mWindowManager = new WindowManagerImpl(); public static WindowManagerImpl getDefault()&#123; return mWindowManager;&#125; 6. new LocalWindowManager(wm)12345678910111213private class LocalWindowManager implements WindowManager &#123; LocalWindowManager(WindowManager wm) &#123; mWindowManager = wm; mDefaultDisplay = mContext.getResources().getDefaultDisplay( mWindowManager.getDefaultDisplay()); &#125; ...... private final WindowManager mWindowManager; private final Display mDefaultDisplay; &#125; 以上就是Activity中Window的创建和初始化过程。 7. Activity.setContentView123public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID);&#125; 8. PhoneWindow.setContentView12345678910111213@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else &#123; mContentParent.removeAllViews(); &#125; mLayoutInflater.inflate(layoutResID, mContentParent); final Callback cb = getCallback(); if (cb != null) &#123; cb.onContentChanged(); &#125;&#125; 9. PhoneWindow.installDecor123456789101112131415161718192021222324252627private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); mTitleView = (TextView)findViewById(com.android.internal.R.id.title); if (mTitleView != null) &#123; if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; View titleContainer = findViewById(com.android.internal.R.id.title_container); if (titleContainer != null) &#123; titleContainer.setVisibility(View.GONE); &#125; else &#123; mTitleView.setVisibility(View.GONE); &#125; if (mContentParent instanceof FrameLayout) &#123; ((FrameLayout)mContentParent).setForeground(null); &#125; &#125; else &#123; mTitleView.setText(mTitle); &#125; &#125; &#125;&#125; 10. PhoneWindow.generateDecor123456789101112protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125;private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; public DecorView(Context context, int featureId) &#123; super(context); mFeatureId = featureId; &#125;&#125; 这里就是新建一个DecorView，DecorView是继承FrameLayout，是根View。 11. PhoneWindow.generateLayout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle(); if (false) &#123; System.out.println("From style:"); String s = "Attrs:"; for (int i = 0; i &lt; com.android.internal.R.styleable.Window.length; i++) &#123; s = s + " " + Integer.toHexString(com.android.internal.R.styleable.Window[i]) + "=" + a.getString(i); &#125; System.out.println(s); &#125; mIsFloating = a.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating, false); int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR) &amp; (~getForcedWindowFlags()); if (mIsFloating) &#123; setLayout(WRAP_CONTENT, WRAP_CONTENT); setFlags(0, flagsToUpdate); &#125; else &#123; setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate); &#125; if (a.getBoolean(com.android.internal.R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; if (a.getBoolean(com.android.internal.R.styleable.Window_windowFullscreen, false)) &#123; setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN&amp;(~getForcedWindowFlags())); &#125; if (a.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper, false)) &#123; setFlags(FLAG_SHOW_WALLPAPER, FLAG_SHOW_WALLPAPER&amp;(~getForcedWindowFlags())); &#125; WindowManager.LayoutParams params = getAttributes(); if (!hasSoftInputMode()) &#123; params.softInputMode = a.getInt( com.android.internal.R.styleable.Window_windowSoftInputMode, params.softInputMode); &#125; if (a.getBoolean(com.android.internal.R.styleable.Window_backgroundDimEnabled, mIsFloating)) &#123; /* All dialogs should have the window dimmed */ if ((getForcedWindowFlags()&amp;WindowManager.LayoutParams.FLAG_DIM_BEHIND) == 0) &#123; params.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND; &#125; params.dimAmount = a.getFloat( android.R.styleable.Window_backgroundDimAmount, 0.5f); &#125; if (params.windowAnimations == 0) &#123; params.windowAnimations = a.getResourceId( com.android.internal.R.styleable.Window_windowAnimationStyle, 0); &#125; // The rest are only done if this window is not embedded; otherwise, // the values are inherited from our container. if (getContainer() == null) &#123; if (mBackgroundDrawable == null) &#123; if (mBackgroundResource == 0) &#123; mBackgroundResource = a.getResourceId( com.android.internal.R.styleable.Window_windowBackground, 0); &#125; if (mFrameResource == 0) &#123; mFrameResource = a.getResourceId(com.android.internal.R.styleable.Window_windowFrame, 0); &#125; if (false) &#123; System.out.println("Background: " + Integer.toHexString(mBackgroundResource) + " Frame: " + Integer.toHexString(mFrameResource)); &#125; &#125; mTextColor = a.getColor(com.android.internal.R.styleable.Window_textColor, 0xFF000000); &#125; // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println("Features: 0x" + Integer.toHexString(features)); if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; layoutResource = com.android.internal.R.layout.dialog_title_icons; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_title_icons; &#125; // System.out.println("Title Icons!"); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0) &#123; layoutResource = com.android.internal.R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; layoutResource = com.android.internal.R.layout.dialog_custom_title; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_custom_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) &#123; layoutResource = com.android.internal.R.layout.dialog_title; &#125; else &#123; layoutResource = com.android.internal.R.layout.screen_title; &#125; // System.out.println("Title!"); &#125; else &#123; // Embedded, so no decoration is needed. layoutResource = com.android.internal.R.layout.screen_simple; // System.out.println("Simple!"); &#125; mDecor.startChanging(); View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException("Window couldn't find content container view"); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) &#123; ProgressBar progress = getCircularProgressBar(false); if (progress != null) &#123; progress.setIndeterminate(true); &#125; &#125; // Remaining setup -- of background and title -- that only applies // to top-level windows. if (getContainer() == null) &#123; Drawable drawable = mBackgroundDrawable; if (mBackgroundResource != 0) &#123; drawable = getContext().getResources().getDrawable(mBackgroundResource); &#125; mDecor.setWindowBackground(drawable); drawable = null; if (mFrameResource != 0) &#123; drawable = getContext().getResources().getDrawable(mFrameResource); &#125; mDecor.setWindowFrame(drawable); // System.out.println("Text=" + Integer.toHexString(mTextColor) + // " Sel=" + Integer.toHexString(mTextSelectedColor) + // " Title=" + Integer.toHexString(mTitleColor)); if (mTitleColor == 0) &#123; mTitleColor = mTextColor; &#125; if (mTitle != null) &#123; setTitle(mTitle); &#125; setTitleColor(mTitleColor); &#125; mDecor.finishChanging(); return contentParent;&#125; 虽然这里的代码很多，其实就是设置Activity主题、ActionBar等内容，然后将显示content的ViewGroup返回。 12. ActivityThread.handleResumeActivity在Activity启动流程的34步，在Activity 初始化和create，调用handleResumeActivity12345678910111213141516171819202122232425262728293031323334353637383940414243final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) &#123; final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; &#125; &#125; else &#123; &#125;&#125; 这里的getWindowManager就是第六步设置的LocalWindowManager 13. LocalWindowManager.addView1234public final void addView(View view, ViewGroup.LayoutParams params) &#123; .... mWindowManager.addView(view, params);&#125; 14. WindowManagerImpl.addView1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private void addView(View view, ViewGroup.LayoutParams params, boolean nest)&#123; if (Config.LOGV) Log.v("WindowManager", "addView view=" + view); if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException( "Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; ViewRoot root; View panelParentView = null; synchronized (this) &#123; // Here's an odd/questionable case: if someone tries to add a // view multiple times, then we simply bump up a nesting count // and they need to remove the view the corresponding number of // times to have it actually removed from the window manager. // This is useful specifically for the notification manager, // which can continually add/remove the same view as a // notification gets updated. int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (!nest) &#123; throw new IllegalStateException("View " + view + " has already been added to the window manager."); &#125; root = mRoots[index]; root.mAddNesting++; // Update layout parameters. view.setLayoutParams(wparams); root.setLayoutParams(wparams, true); return; &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews != null ? mViews.length : 0; for (int i=0; i&lt;count; i++) &#123; if (mRoots[i].mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews[i]; &#125; &#125; &#125; root = new ViewRoot(view.getContext()); root.mAddNesting = 1; view.setLayoutParams(wparams); if (mViews == null) &#123; index = 1; mViews = new View[1]; mRoots = new ViewRoot[1]; mParams = new WindowManager.LayoutParams[1]; &#125; else &#123; index = mViews.length + 1; Object[] old = mViews; mViews = new View[index]; System.arraycopy(old, 0, mViews, 0, index-1); old = mRoots; mRoots = new ViewRoot[index]; System.arraycopy(old, 0, mRoots, 0, index-1); old = mParams; mParams = new WindowManager.LayoutParams[index]; System.arraycopy(old, 0, mParams, 0, index-1); &#125; index--; mViews[index] = view; mRoots[index] = root; mParams[index] = wparams; &#125; // do this last because it fires off messages to start doing things root.setView(view, wparams, panelParentView);&#125; WindowManagerImpl类有三个成员变量mViews、mRoots和mParams，它们分别是类型为View、ViewRoot和WindowManager.LayoutParams的数组。这三个数组的大小是始终保持相等的。这样， 有关联关系的View对象、ViewRoot对象和WindowManager.LayoutParams对象就会分别保存在数组mViews、mRoots和mParams的相同位置上，也就是说，mViews[i]、mRoots[i]和mParams[i]所描述的View对象、ViewRoot对象和WindowManager.LayoutParams对象是具有关联关系的。因此，WindowManagerImpl类的三个参数版本的成员函数addView在关联一个View对象、一个ViewRoot对象和一个WindowManager.LayoutParams对象的时候，只要分别将它们放在数组mViews、mRoots和mParams的相同位置上就可以了。 15. ViewRoot.setView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; mWindowAttributes.copyFrom(attrs); attrs = mWindowAttributes; if (view instanceof RootViewSurfaceTaker) &#123; mSurfaceHolderCallback = ((RootViewSurfaceTaker)view).willYouTakeTheSurface(); if (mSurfaceHolderCallback != null) &#123; mSurfaceHolder = new TakenSurfaceHolder(); mSurfaceHolder.setFormat(PixelFormat.UNKNOWN); &#125; &#125; Resources resources = mView.getContext().getResources(); CompatibilityInfo compatibilityInfo = resources.getCompatibilityInfo(); mTranslator = compatibilityInfo.getTranslator(); boolean restore = false; if (mTranslator != null) &#123; restore = true; attrs.backup(); mTranslator.translateWindowLayout(attrs); &#125; if (DEBUG_LAYOUT) Log.d(TAG, "WindowLayout in setView:" + attrs); if (!compatibilityInfo.supportsScreen()) &#123; attrs.flags |= WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW; &#125; mSoftInputMode = attrs.softInputMode; mWindowAttributesChanged = true; mAttachInfo.mRootView = view; mAttachInfo.mScalingRequired = mTranslator != null; mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale; if (panelParentView != null) &#123; mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken(); &#125; mAdded = true; int res; /* = WindowManagerImpl.ADD_OKAY; */ // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. requestLayout(); mInputChannel = new InputChannel(); try &#123; res = sWindowSession.add(mWindow, mWindowAttributes, getHostVisibility(), mAttachInfo.mContentInsets, mInputChannel); &#125; catch (RemoteException e) &#123; &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; &#125; &#125;&#125; 这里会请求Layout计算视图的大小，然后通过sWindowSession通知WindowManagerService添加视图，sWindowSession是Binder对象。 16. 总结首先是Activity的初始化会创建一个Window对象，初始化window对象中的数据，然后调用生命周期onCreate方法，然后设置ContentView，其实调用的是Window中的ContentView，Window对象中会新建DecorView（根布局），然后将自定义的View添加到DecorView中，然后ActivityThread调用到handleResumeActivity,将DecorView添加到ViewRoot中，ViewRoot中含有WindowManagerService的远程Binder对象，然后调用WindowManagerService将DecorView显示在界面中。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Activity</tag>
        <tag>Window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android程序Activity启动流程]]></title>
    <url>%2F2015%2F08%2F12%2FActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[在学习这张之前请先学习Android IPC进程通信。在Android系统中，有两种操作会引发Activity的启动，一种用户点击应用程序图标时，Launcher会为我们启动应用程序的主Activity；应用程序的默认Activity启动起来后，它又可以在内部通过调用startActvity接口启动新的Activity，依此类推，每一个Activity都可以在内部启动新的Activity。所以首先我们将分析第一种情况。 以下代码只看主干和重要部分，其他将省略，有兴趣自己翻源码。 1.首先查看Launcher.java（桌面）中的onClick方法。123456789101112131415161718192021222324public void onClick(View v) &#123; Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; // Open shortcut final Intent intent = ((ShortcutInfo) tag).intent; int[] pos = new int[2]; v.getLocationOnScreen(pos); intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight())); startActivitySafely(intent, tag); &#125; else if (tag instanceof FolderInfo) &#123; &#125; else if (v == mHandleView) &#123; &#125;&#125; void startActivitySafely(Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; &#125; catch (SecurityException e) &#123; &#125;&#125; 这里将启动程序的主Activity，因为每个程序对应ActivityTask，所以设置intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)。 2.Activity.startActivityForResul12345678910111213141516171819202122232425public void startActivityForResult(Intent intent, int requestCode) &#123; if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; &#125; else &#123; mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; 这里mMainThread就是程序的主线程ActivityThread，mMainThread.getApplicationThread()就是ApplicationThread，ApplicationThread其实是一个Binder，作用是和ActivityManagerService通信。mToken是ActivityRecord，主要记录Activity信息，也是一个Binder。 3.Instrumentation.execStartActivity123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; &#125; try &#123; int result = ActivityManagerNative.getDefault() .startActivity(whoThread, intent, intent.resolveTypeIfNeeded(who.getContentResolver()), null, 0, token, target != null ? target.mEmbeddedID : null, requestCode, false, false); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; ActivityManagerNative.getDefault()获取ActivityManagerService的远程代理接口。 4. ActivityManagerProxy.startActivity,ActivityManagerProxy是ActivityManagerNative的内部类。12345678910111213141516171819202122232425public int startActivity(IApplicationThread caller, Intent intent, String resolvedType, Uri[] grantedUriPermissions, int grantedMode, IBinder resultTo, String resultWho, int requestCode, boolean onlyIfNeeded, boolean debug) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeTypedArray(grantedUriPermissions, 0); data.writeInt(grantedMode); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(onlyIfNeeded ? 1 : 0); data.writeInt(debug ? 1 : 0); mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result;&#125; 这里的参数比较多，我们先整理一下。从上面的调用可以知道，这里的参数resolvedType、grantedUriPermissions和resultWho均为null；参数caller为ApplicationThread类型的Binder实体；参数resultTo为一个Binder实体(ActivityRecord)的远程接口，我们先不关注它；参数grantedMode为0，我们也先不关注它；参数requestCode为-1；参数onlyIfNeeded和debug均空false。 5.ActivityManagerService.startActivity123456789public final int startActivity(IApplicationThread caller, Intent intent, String resolvedType, Uri[] grantedUriPermissions, int grantedMode, IBinder resultTo, String resultWho, int requestCode, boolean onlyIfNeeded, boolean debug) &#123; return mMainStack.startActivityMayWait(caller, intent, resolvedType, grantedUriPermissions, grantedMode, resultTo, resultWho, requestCode, onlyIfNeeded, debug, null, null);&#125; 6.ActivityStack.startActivityMayWait123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final int startActivityMayWait(IApplicationThread caller, Intent intent, String resolvedType, Uri[] grantedUriPermissions, int grantedMode, IBinder resultTo, String resultWho, int requestCode, boolean onlyIfNeeded, boolean debug, WaitResult outResult, Configuration config) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors()) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; boolean componentSpecified = intent.getComponent() != null; // Don't modify the client's object! intent = new Intent(intent); // Collect information about the target of the Intent. ActivityInfo aInfo; try &#123; ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent( intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS); aInfo = rInfo != null ? rInfo.activityInfo : null; &#125; catch (RemoteException e) &#123; aInfo = null; &#125; synchronized (mService) &#123; int callingPid; int callingUid; if (caller == null) &#123; callingPid = Binder.getCallingPid(); callingUid = Binder.getCallingUid(); &#125; else &#123; callingPid = callingUid = -1; &#125; int res = startActivityLocked(caller, intent, resolvedType, grantedUriPermissions, grantedMode, aInfo, resultTo, resultWho, requestCode, callingPid, callingUid, onlyIfNeeded, componentSpecified); return res; &#125;&#125; 7. ActivityStack.startActivityLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, Uri[] grantedUriPermissions, int grantedMode, ActivityInfo aInfo, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, boolean onlyIfNeeded, boolean componentSpecified) &#123; int err = START_SUCCESS; ProcessRecord callerApp = null; if (caller != null) &#123; callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; Slog.w(TAG, "Unable to find app for caller " + caller + " (pid=" + callingPid + ") when starting: " + intent.toString()); err = START_PERMISSION_DENIED; &#125; &#125; if (err == START_SUCCESS) &#123; Slog.i(TAG, "Starting: " + intent + " from pid " + (callerApp != null ? callerApp.pid : callingPid)); &#125; ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; if (resultTo != null) &#123; int index = indexOfTokenLocked(resultTo); if (DEBUG_RESULTS) Slog.v( TAG, "Sending result to " + resultTo + " (index " + index + ")"); if (index &gt;= 0) &#123; sourceRecord = (ActivityRecord)mHistory.get(index); if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; resultRecord = sourceRecord; &#125; &#125; &#125; int launchFlags = intent.getFlags(); if ((launchFlags&amp;Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; // Transfer the result target from the source activity to the new // one being started, including any failures. if (requestCode &gt;= 0) &#123; return START_FORWARD_AND_REQUEST_CONFLICT; &#125; resultRecord = sourceRecord.resultTo; resultWho = sourceRecord.resultWho; requestCode = sourceRecord.requestCode; sourceRecord.resultTo = null; if (resultRecord != null) &#123; resultRecord.removeResultsLocked( sourceRecord, resultWho, requestCode); &#125; &#125; ActivityRecord r = new ActivityRecord(mService, this, callerApp, callingUid, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified); return startActivityUncheckedLocked(r, sourceRecord, grantedUriPermissions, grantedMode, onlyIfNeeded, true);&#125; 将所有的信息保存到ActivityRecord r中 8. ActivityStack.startActivityUncheckedLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, Uri[] grantedUriPermissions, int grantedMode, boolean onlyIfNeeded, boolean doResume) &#123; final Intent intent = r.intent; final int callingUid = r.launchedFromUid; int launchFlags = intent.getFlags(); // If the caller has asked not to resume at this point, we make note // of this in the record so that we can skip it when trying to find // the top running activity. if (!doResume) &#123; r.delayedResume = true; &#125; ActivityRecord notTop = (launchFlags&amp;Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null; boolean addingToTask = false; if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; // If bring to front is requested, and no result is requested, and // we can find a task that was started with this same // component, then instead of launching bring that one to the front. if (r.resultTo == null) &#123; // See if there is a task to bring to the front. If this is // a SINGLE_INSTANCE activity, there can be one and only one // instance of it in the history, and it is always in its own // unique task, so we do a special search. ActivityRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent, r.info) : findActivityLocked(intent, r.info); if (taskTop != null) &#123; &#125; &#125; &#125; if (r.packageName != null) &#123; // If the activity being launched is the same as the one currently // at the top, then we need to check if it should only be launched // once. ActivityRecord top = topRunningNonDelayedActivityLocked(notTop); if (top != null &amp;&amp; r.resultTo == null) &#123; if (top.realActivity.equals(r.realActivity)) &#123; if (top.app != null &amp;&amp; top.app.thread != null) &#123; if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) &#123; logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task); // For paranoia, make sure we have correctly // resumed the top activity. if (doResume) &#123; resumeTopActivityLocked(null); &#125; if (onlyIfNeeded) &#123; // We don't need to start a new activity, and // the client said not to do anything if that // is the case, so this is it! return START_RETURN_INTENT_TO_CALLER; &#125; top.deliverNewIntentLocked(callingUid, r.intent); return START_DELIVERED_TO_TOP; &#125; &#125; &#125; &#125; &#125; else &#123; if (r.resultTo != null) &#123; sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); &#125; return START_CLASS_NOT_FOUND; &#125; boolean newTask = false; // Should this be considered a new task? if (r.resultTo == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; // todo: should do better management of integers. mService.mCurTask++; if (mService.mCurTask &lt;= 0) &#123; mService.mCurTask = 1; &#125; r.task = new TaskRecord(mService.mCurTask, r.info, intent, (r.info.flags&amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0); if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r + " in new task " + r.task); newTask = true; if (mMainStack) &#123; mService.addRecentTaskLocked(r.task); &#125; &#125; else if (sourceRecord != null) &#123; &#125; else &#123; &#125; logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task); startActivityLocked(r, newTask, doResume); return START_SUCCESS;&#125; 这里launchFlags是的启动模式，ActivityRecord taskTop 获取最顶层Activity，但是由于是新开启的程序，没有Activity，所以taskTop为null。然后新建一个TaskRecord，TaskRecord表示Activity任务栈，然后保存到r中。TaskRecord中其实并没有包含Activity的列表，所以在查找某个Activity栈中的Activity需要遍历ActivityManagerService中的的ActivityRecord，然后根据ActivityRecord中的TaskRecord查找同一个栈内的Activity，所以要将TaskRecord保存到r中。 9. ActivityStack.resumeTopActivityLocked123456789101112131415161718192021222324252627282930313233343536373839404142private final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume) &#123; final int NH = mHistory.size(); int addPos = -1; if (!newTask) &#123; // If starting in an existing task, find where that is... boolean startIt = true; for (int i = NH-1; i &gt;= 0; i--) &#123; ActivityRecord p = (ActivityRecord)mHistory.get(i); if (p.finishing) &#123; continue; &#125; if (p.task == r.task) &#123; // Here it is! Now, if this is not yet visible to the // user, then just add it without starting; it will // get started when the user navigates back to it. addPos = i+1; if (!startIt) &#123; mHistory.add(addPos, r); r.inHistory = true; r.task.numActivities++; mService.mWindowManager.addAppToken(addPos, r, r.task.taskId, r.info.screenOrientation, r.fullscreen); if (VALIDATE_TOKENS) &#123; mService.mWindowManager.validateAppTokens(mHistory); &#125; return; &#125; break; &#125; if (p.fullscreen) &#123; startIt = false; &#125; &#125; &#125; if (doResume) &#123; resumeTopActivityLocked(null); &#125;&#125; 10. ActivityStack.resumeTopActivityLocked12345678910111213141516171819202122232425262728293031final boolean resumeTopActivityLocked(ActivityRecord prev) &#123; // Find the first activity that is not finishing. ActivityRecord next = topRunningActivityLocked(null); // Remember how we'll process this pause/resume situation, and ensure // that the state is reset however we wind up proceeding. final boolean userLeaving = mUserLeaving; mUserLeaving = false; if (next == null) &#123; // There are no more activities! Let's just start up the // Launcher... if (mMainStack) &#123; return mService.startHomeActivityLocked(); &#125; &#125; next.delayedResume = false; // We need to start pausing the current activity so the top one // can be resumed... if (mResumedActivity != null) &#123; if (DEBUG_SWITCH) Slog.v(TAG, "Skip resume: need to start pausing"); startPausingLocked(userLeaving, false); return true; &#125; return true;&#125; 11. ActivityStack.startPausingLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445private final void startPausingLocked(boolean userLeaving, boolean uiSleeping) &#123; if (mPausingActivity != null) &#123; RuntimeException e = new RuntimeException(); Slog.e(TAG, "Trying to pause when pause is already pending for " + mPausingActivity, e); &#125; ActivityRecord prev = mResumedActivity; if (prev == null) &#123; RuntimeException e = new RuntimeException(); Slog.e(TAG, "Trying to pause when nothing is resumed", e); resumeTopActivityLocked(null); return; &#125; if (DEBUG_PAUSE) Slog.v(TAG, "Start pausing: " + prev); mResumedActivity = null; mPausingActivity = prev; mLastPausedActivity = prev; prev.state = ActivityState.PAUSING; prev.task.touchActiveTime(); mService.updateCpuStats(); if (prev.app != null &amp;&amp; prev.app.thread != null) &#123; if (DEBUG_PAUSE) Slog.v(TAG, "Enqueueing pending pause: " + prev); try &#123; EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, System.identityHashCode(prev), prev.shortComponentName); prev.app.thread.schedulePauseActivity(prev, prev.finishing, userLeaving, prev.configChangeFlags); if (mMainStack) &#123; mService.updateUsageStats(prev, false); &#125; &#125; catch (Exception e) &#123; // Ignore exception, if process died other code will cleanup. Slog.w(TAG, "Exception thrown during pause", e); mPausingActivity = null; mLastPausedActivity = null; &#125; &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; &#125;&#125; prev.app.thread.schedulePauseActivity调用ApplicationThreadProxy的schedulePauseActivity方法。 12. ApplicationThreadProxy.schedulePauseActivity123456789101112 public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); data.writeInt(finished ? 1 : 0); data.writeInt(userLeaving ? 1 :0); data.writeInt(configChanges); mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 13. ApplicationThread.schedulePauseActivity, ApplicationThread是ActivityThread的内部类。12345678public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) &#123; queueOrSendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0), configChanges);&#125; 14. ActivityThread.queueOrSendMessage12345678910111213private final void queueOrSendMessage(int what, Object obj, int arg1, int arg2) &#123; synchronized (this) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, "SCHEDULE " + what + " " + mH.codeToString(what) + ": " + arg1 + " / " + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; mH.sendMessage(msg); &#125;&#125; 15. ActivityThread.H.handleMessage1234case PAUSE_ACTIVITY:handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2);maybeSnapshot();break; ####16. ActivityThread.handlePauseActivity12345678910111213141516171819202122private final void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; //Slog.v(TAG, "userLeaving=" + userLeaving + " handling pause of " + r); if (userLeaving) &#123; performUserLeavingActivity(r); &#125; r.activity.mConfigChangeFlags |= configChanges; Bundle state = performPauseActivity(token, finished, true); // Make sure any pending writes are now committed. QueuedWork.waitToFinish(); // Tell the activity manager we have paused. try &#123; ActivityManagerNative.getDefault().activityPaused(token, state); &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; 通过performPause将Activityactivity pause， 然后ActivityManagerNative.getDefault().activityPaused(token, state)通知ActivityManagerSerice。 12345678910111213141516171819202122232425262728293031323334353637final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) &#123; if (r.paused) &#123; if (r.activity.mFinished) &#123; return null; &#125; &#125; Bundle state = null; if (finished) &#123; r.activity.mFinished = true; &#125; try &#123; // Next have the activity save its current state and managed dialogs... if (!r.activity.mFinished &amp;&amp; saveState) &#123; state = new Bundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, state); r.state = state; &#125; // Now we are idle. r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); EventLog.writeEvent(LOG_ON_PAUSE_CALLED, r.activity.getComponentName().getClassName()); if (!r.activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onPause()"); &#125; &#125; catch (SuperNotCalledException e) &#123; &#125; catch (Exception e) &#123; &#125; r.paused = true; return state;&#125; 123456789101112131415public void callActivityOnPause(Activity activity) &#123; activity.performPause();&#125;final void performPause() &#123; mCalled = false; onPause(); if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123; throw new SuperNotCalledException( "Activity " + mComponent.toShortString() + " did not call through to super.onPause()"); &#125; mResumed = false;&#125; 17. ActivityManagerService.activityPaused12345678910public final void activityPaused(IBinder token, Bundle icicle) &#123; // Refuse possible leaked file descriptors if (icicle != null &amp;&amp; icicle.hasFileDescriptors()) &#123; throw new IllegalArgumentException("File descriptors passed in Bundle"); &#125; final long origId = Binder.clearCallingIdentity(); mMainStack.activityPaused(token, icicle, false); Binder.restoreCallingIdentity(origId);&#125; 18. MainStack.activityPaused1234567891011121314151617181920212223final void activityPaused(IBinder token, Bundle icicle, boolean timeout) &#123; if (DEBUG_PAUSE) Slog.v( TAG, "Activity paused: token=" + token + ", icicle=" + icicle + ", timeout=" + timeout); ActivityRecord r = null; synchronized (mService) &#123; int index = indexOfTokenLocked(token); if (index &gt;= 0) &#123; r = (ActivityRecord)mHistory.get(index); if (!timeout) &#123; &#125; if (mPausingActivity == r) &#123; r.state = ActivityState.PAUSED; completePauseLocked(); &#125; else &#123; &#125; &#125; &#125;&#125; 19. MainStack.completePauseLocked12345678910111213141516171819202122232425262728293031323334353637383940414243private final void completePauseLocked() &#123; ActivityRecord prev = mPausingActivity; if (DEBUG_PAUSE) Slog.v(TAG, "Complete pause: " + prev); if (prev != null) &#123; if (prev.finishing) &#123; if (DEBUG_PAUSE) Slog.v(TAG, "Executing finish of activity: " + prev); prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE); &#125; else if (prev.app != null) &#123; if (prev.configDestroy) &#123; destroyActivityLocked(prev, true); &#125; else &#123; mStoppingActivities.add(prev); &#125; &#125; &#125; else &#123; if (DEBUG_PAUSE) Slog.v(TAG, "App died during pause, not stopping: " + prev); prev = null; &#125; mPausingActivity = null; &#125; if (!mService.mSleeping &amp;&amp; !mService.mShuttingDown) &#123; resumeTopActivityLocked(prev); &#125; else &#123; if (mGoingToSleep.isHeld()) &#123; mGoingToSleep.release(); &#125; if (mService.mShuttingDown) &#123; mService.notifyAll(); &#125; &#125; if (prev != null) &#123; prev.resumeKeyDispatchingLocked(); &#125; if (prev.app != null &amp;&amp; prev.cpuTimeAtResume &gt; 0 &#125; prev.cpuTimeAtResume = 0; // reset it&#125; 20. MainStack.resumeTopActivityLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final boolean resumeTopActivityLocked(ActivityRecord prev) &#123; // Find the first activity that is not finishing. ActivityRecord next = topRunningActivityLocked(null); // Remember how we'll process this pause/resume situation, and ensure // that the state is reset however we wind up proceeding. final boolean userLeaving = mUserLeaving; mUserLeaving = false; if (next == null) &#123; // There are no more activities! Let's just start up the // Launcher... if (mMainStack) &#123; return mService.startHomeActivityLocked(); &#125; &#125; next.delayedResume = false; // The activity may be waiting for stop, but that is no longer // appropriate for it. mStoppingActivities.remove(next); mWaitingVisibleActivities.remove(next); if (DEBUG_SWITCH) Slog.v(TAG, "Resuming " + next); // If we are currently pausing an activity, then don't do anything // until that is done. if (mPausingActivity != null) &#123; if (DEBUG_SWITCH) Slog.v(TAG, "Skip resume: pausing=" + mPausingActivity); return false; &#125; if (next.app != null &amp;&amp; next.app.thread != null) &#123; &#125; else &#123; // Whoops, need to restart this activity! if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW) &#123; mService.mWindowManager.setAppStartingWindow( next, next.packageName, next.theme, next.nonLocalizedLabel, next.labelRes, next.icon, null, true); &#125; if (DEBUG_SWITCH) Slog.v(TAG, "Restarting: " + next); &#125; startSpecificActivityLocked(next, true, true); &#125; return true;&#125; 因为新的程序还未开始，所以app和Thread为null，调用startSpecificActivityLocked； 21. MainStack.startSpecificActivityLocked12345678910111213141516171819202122232425262728293031private final void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid); if (r.launchTime == 0) &#123; r.launchTime = SystemClock.uptimeMillis(); if (mInitialStartTime == 0) &#123; mInitialStartTime = r.launchTime; &#125; &#125; else if (mInitialStartTime == 0) &#123; mInitialStartTime = SystemClock.uptimeMillis(); &#125; if (app != null &amp;&amp; app.thread != null) &#123; try &#123; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false);&#125; mService就是ActivityManagerService。 22. ActivityManagerService.startProcessLocked1234567891011121314151617181920final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting) &#123; ProcessRecord app = getProcessRecordLocked(processName, info.uid); String hostingNameStr = hostingName != null ? hostingName.flattenToShortString() : null; if (app == null) &#123; app = newProcessRecordLocked(null, info, processName); mProcessNames.put(processName, info.uid, app); &#125; else &#123; &#125; startProcessLocked(app, hostingType, hostingNameStr); return (app.pid != 0) ? app : null;&#125; 23. ActivityManagerService.startProcessLocked1234567891011121314private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; try &#123; int uid = app.info.uid; int[] gids = null; int pid = Process.start("android.app.ActivityThread", mSimpleProcessManagement ? app.processName : null, uid, uid, gids, debugFlags, null); BatteryStatsImpl bs = app.batteryStats.getBatteryStats(); &#125; 这里直接实例化 android.app.ActivityThread，调用main方法。 24. ActivityThread.main123456789101112131415161718192021222324public static final void main(String[] args) &#123; SamplingProfilerIntegration.start(); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); if (sMainThreadHandler == null) &#123; sMainThreadHandler = new Handler(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(false); Looper.loop(); if (Process.supportsProcesses()) &#123; throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; thread.detach(); String name = (thread.mInitialApplication != null) ? thread.mInitialApplication.getPackageName() : "&lt;unknown&gt;";&#125; main中开启Handler消息循环，处理消息，然后调用thread.attach(false)。 25. ActivityThread.attach1234567891011121314151617181920private final void attach(boolean system) &#123; sThreadLocal.set(this); mSystemThread = system; if (!system) &#123; ViewRoot.addFirstDrawHandler(new Runnable() &#123; public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName("&lt;pre-initialized&gt;"); RuntimeInit.setApplicationObject(mAppThread.asBinder()); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; &#125; &#125; else &#123; &#125;&#125; 调用ActivityManagerProxy的attachApplication，主要是把Appliccation的远程引用传递给ActivityManagerService。 26. ActivityManagerProxy.attachApplication1234567891011public void attachApplication(IApplicationThread app) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 通过IPC调用ActivityManagerService的attachApplication。 27. ActivityManagerService.attachApplication12345678public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; 28. ActivityManagerService.attachApplicationLocked12345678910111213141516171819202122232425262728293031323334353637383940414243private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ProcessRecord app; app.thread = thread; app.curAdj = app.setAdj = -100; app.curSchedGroup = Process.THREAD_GROUP_DEFAULT; app.setSchedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE; app.forcingToForeground = null; app.foregroundServices = false; app.debugging = false; mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); List providers = normalMode ? generateApplicationProvidersLocked(app) : null; // Remove this record from the list of starting applications. mPersistentStartingProcesses.remove(app); if (DEBUG_PROCESSES &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(TAG, "Attach application locked removing on hold: " + app); mProcessesOnHold.remove(app); boolean badApp = false; boolean didSomething = false; // See if the top visible activity is waiting to run in this process... ActivityRecord hr = mMainStack.topRunningActivityLocked(null); if (hr != null &amp;&amp; normalMode) &#123; if (hr.app == null &amp;&amp; app.info.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (mMainStack.realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; &#125; &#125; else &#123; &#125; &#125; return true;&#125; 之前已经创建了一个ProcessRecord，这里首先通过pid将它取回来，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作。这里要启动的Activity通过调用mMainStack.topRunningActivityLocked(null)从堆栈顶端取回来，这时候在堆栈顶端的Activity就是MainActivity了。 29. mMainStack.realStartActivityLocked1234567891011121314151617181920212223242526272829303132333435363738394041424344final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; r.app = app; if (localLOGV) Slog.v(TAG, "Launching: " + r); int idx = app.activities.indexOf(r); if (idx &lt; 0) &#123; app.activities.add(r); &#125; try &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; List&lt;ResultInfo&gt; results = null; List&lt;Intent&gt; newIntents = null; if (andResume) &#123; results = r.results; newIntents = r.newIntents; &#125; if (r.isHomeActivity) &#123; mService.mHomeProcess = app; &#125; app.thread.scheduleLaunchActivity(new Intent(r.intent), r, System.identityHashCode(r), r.info, r.icicle, results, newIntents, !andResume, mService.isNextTransitionForward()); if ((app.info.flags&amp;ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) &#123; &#125; &#125; catch (RemoteException e) &#123; &#125; return true;&#125; 30.ApplicationThreadProxy.scheduleLaunchActivity12345678910111213141516171819public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); intent.writeToParcel(data, 0); data.writeStrongBinder(token); data.writeInt(ident); info.writeToParcel(data, 0); data.writeBundle(state); data.writeTypedList(pendingResults); data.writeTypedList(pendingNewIntents); data.writeInt(notResumed ? 1 : 0); data.writeInt(isForward ? 1 : 0); mRemote.transact(SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 31. ApplicationThread.scheduleLaunchActivity12345678910111213141516171819public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward) &#123; ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.activityInfo = info; r.state = state; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; queueOrSendMessage(H.LAUNCH_ACTIVITY, r);&#125; 32. ActivityThread.queueOrSendMessage1234567891011121314151617private final void queueOrSendMessage(int what, Object obj) &#123; queueOrSendMessage(what, obj, 0, 0);&#125;private final void queueOrSendMessage(int what, Object obj, int arg1, int arg2) &#123; synchronized (this) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, "SCHEDULE " + what + " " + mH.codeToString(what) + ": " + arg1 + " / " + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; mH.sendMessage(msg); &#125;&#125; 33. ActivityThread.H.handleMessage1234567case LAUNCH_ACTIVITY: &#123; ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo); handleLaunchActivity(r, null);&#125; break; 34. ActivityThread.handleLaunchActivity12345678910111213private final void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; are back active so skip it. unscheduleGcIdler(); Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward); &#125;else &#123; &#125;&#125; 35. ActivityThread.performLaunchActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private final Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, Context.CONTEXT_INCLUDE_CODE); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); r.intent.setExtrasClassLoader(cl); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; ContextImpl appContext = new ContextImpl(); appContext.init(r.packageInfo, r.token, this); appContext.setOuterContext(activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstance, r.lastNonConfigurationChildInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstance = null; r.lastNonConfigurationChildInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; mInstrumentation.callActivityOnCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; mInstrumentation.callActivityOnPostCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onPostCreate()"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; &#125; catch (Exception e) &#123; &#125; return activity;&#125; 这里主要通过反射实例化Activity，然后初始化Activity中的数据，最后调用Activity的生命周期方法，到此基本结束所以流程。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进程通信]]></title>
    <url>%2F2015%2F08%2F10%2F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[Android进程通信采用的是Binder架构，Binder架构提供了服务端、Binder驱动、客户端三个模块。客户端获取服务端的远程引用调用服务端的方法。 1.Binder架构和流程图由图可知，客户端需要通过Binder驱动获取服务端的远程引用Binder对象mRemote，然后调用transact方法来触发服务端的onTransact方法，实现进程通信。 2. 获取mRemote对象通过1中的分析我们知道调用流程，那需要思考怎么获取mRemote。接下来我们分析获取系统服务的Binder。Context是抽象类，实际调用的是ContextImp.getSystemService1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic Object getSystemService(String name) &#123; if (WINDOW_SERVICE.equals(name)) &#123; return WindowManagerImpl.getDefault(); &#125; else if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123; synchronized (mSync) &#123; LayoutInflater inflater = mLayoutInflater; if (inflater != null) &#123; return inflater; &#125; mLayoutInflater = inflater = PolicyManager.makeNewLayoutInflater(getOuterContext()); return inflater; &#125; &#125; else if (ACTIVITY_SERVICE.equals(name)) &#123; return getActivityManager(); &#125; else if (INPUT_METHOD_SERVICE.equals(name)) &#123; return InputMethodManager.getInstance(this); &#125; else if (ALARM_SERVICE.equals(name)) &#123; return getAlarmManager(); &#125; else if (ACCOUNT_SERVICE.equals(name)) &#123; return getAccountManager(); &#125; else if (POWER_SERVICE.equals(name)) &#123; return getPowerManager(); &#125; else if (CONNECTIVITY_SERVICE.equals(name)) &#123; return getConnectivityManager(); &#125; else if (THROTTLE_SERVICE.equals(name)) &#123; return getThrottleManager(); &#125; else if (WIFI_SERVICE.equals(name)) &#123; return getWifiManager(); &#125; else if (NOTIFICATION_SERVICE.equals(name)) &#123; return getNotificationManager(); &#125; else if (KEYGUARD_SERVICE.equals(name)) &#123; return new KeyguardManager(); &#125; else if (ACCESSIBILITY_SERVICE.equals(name)) &#123; return AccessibilityManager.getInstance(this); &#125; else if (LOCATION_SERVICE.equals(name)) &#123; return getLocationManager(); &#125; else if (SEARCH_SERVICE.equals(name)) &#123; return getSearchManager(); &#125; else if (SENSOR_SERVICE.equals(name)) &#123; return getSensorManager(); &#125; else if (STORAGE_SERVICE.equals(name)) &#123; return getStorageManager(); &#125; else if (USB_SERVICE.equals(name)) &#123; return getUsbManager(); &#125; return null; &#125; 随便分析一个12345678910private AlarmManager getAlarmManager() &#123; synchronized (sSync) &#123; if (sAlarmManager == null) &#123; IBinder b = ServiceManager.getService(ALARM_SERVICE); IAlarmManager service = IAlarmManager.Stub.asInterface(b); sAlarmManager = new AlarmManager(service); &#125; &#125; return sAlarmManager;&#125; ServiceManager.getService12345678910111213public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, "error in getService", e); &#125; return null;&#125; 123456789private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125; BinderInternal.getContextObject()静态函数返回ServiceManager对应的全局Binder对象，该函数不需要任何参数，因为它的作用是固定的。而ServiceManager中管理的所以Binder对象都死通过addService方法添加进去的，是系统的Service在Framework启动的的时候完成的。ServiceManager管理所有的Service，客户端可以回去需要的Manager，ServiceManager是一个独立的进程，所以获取Manager的时候也是通过Binder通信获取的。 ServiceManagerNative.asInterface12345678910111213static public IServiceManager asInterface(IBinder obj)&#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj);&#125; 最后其实返回ServiceManagerProxy对象，使用静态代理模式代理IBinder ServiceManagerProxy.getService123456789101112131415public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote;&#125;public IBinder getService(String name) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder;&#125; 最后调用的是传进去的Binder对象transact方法。最后解释asInterface其实就是使用静态代理，最后返回包装后的接口Manager，里面其实调用的还是Binder。 3 自定义服务的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public interface Manager extends android.os.IInterface &#123; /** Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.jc.service.Manager &#123; private static final java.lang.String DESCRIPTOR = "com.jc.service.Manager"; /** Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.jc.service.Manager interface, * generating a proxy if needed. */ public static com.jc.service.Manager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.jc.service.Manager))) &#123; return ((com.jc.service.Manager) iin); &#125; return new com.jc.service.Manager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_callBanzheng: &#123; data.enforceInterface(DESCRIPTOR); this.callBanzheng(); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.jc.service.Manager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public void callBanzheng() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_callBanzheng, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_callBanzheng = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; public void callBanzheng() throws android.os.RemoteException;&#125; 首先可以看到asInterface(android.os.IBinder obj)获取的是Proxy代理对象，然后通过mRemote发送消息给Binder驱动，Binder驱动调用服务端的onTransact，根据code判断调用的方法。 4. 总结ServiceManager是一个全局的Binder管理者，系统的重要进程都在开启的时候通过ServiceManagerProxy向ServiceManager中添加自己，ServiceManagerProxy是一个BpBinder(0)的代理对象。添加完成以后所以的进程可以通过ServiceManager获取其他进程的Binder远程引用对象，从而调用其他进程中的方法。 友情提示，这里讲到的主要是进程通信的基本流程，也是作为自己看书的部分记录。详细了解请看Android进程通信简要介绍和学习计划]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画基础]]></title>
    <url>%2F2015%2F08%2F09%2FAndroid%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Android动画分为补间动画和帧动画两种。补间动画提供旋转、移动、缩放、透明度四种效果；帧动画是通过放置每一帧的图片，按顺序改变图片形成动画效果。然而自Android 3.0版本开始，系统给我们提供了一种全新的动画模式，属性动画(property animation)，它的功能非常强大，弥补了之前补间动画的一些缺陷，几乎是可以完全替代掉补间动画了。虽然可以代替掉，但是作为平时学习的话还是必须了解。 1、补间动画补间动画是可以对View进行一系列的动画操作。 1.1移动动画123456789101112131415161718192021222324252627282930private void translateAnimation() &#123; /** *1.坐标的的类型（ Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, Animation.RELATIVE_TO_PARENT.） *2.x坐标的相对起始位置。这里是0.1就是相对于当前view x坐标 + view长度10%位置。 *3.坐标类型 *4.y坐标的相对起始位置。这里是0.1就是相对于当前view y 坐标 + view高度10%位置。 * */ animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0.1f, Animation.RELATIVE_TO_SELF, 1f); //动画时间 animation.setDuration(1000 * 2); //动画运行完后保持动画完成的效果 animation.setFillAfter(true); animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;);&#125; 1.2缩放动画1234567891011121314151617181920212223242526272829private void scaleAnimation() &#123; /** *1.fromX 起始view长度相对自己本身大小的比值 。（起始view相对与自己的50%） *2.toX 结束view长度相对自己本身大小的比值 。 *3.pivotXType view的相对目标。 *4.pivotXValue 缩放的相对起始位置。（如果是0.5 从中间向四周放大） * */ animation = new ScaleAnimation(0.5f, 1f, 0.5f, 1f, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 0); //动画时间 animation.setDuration(1000 * 2); //动画运行完后保持动画完成的效果 animation.setFillAfter(true); animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;);&#125; 1.3旋转动画1234567891011121314151617181920212223private void rotateAnimation() &#123; animation = new RotateAnimation(0f, 180f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); //动画时间 animation.setDuration(1000 * 2); //动画运行完后保持动画完成的效果 animation.setFillAfter(true); animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;);&#125; 1.4透明度动画1234567891011121314151617181920212223private void alphaAnimation() &#123; animation = new AlphaAnimation(0.5f, 1f); //动画时间 animation.setDuration(1000 * 2); //动画运行完后保持动画完成的效果 animation.setFillAfter(true); animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;);&#125; 1.5动画集合1234567891011private void animationSet() &#123; AnimationSet animationSet = new AnimationSet(true); //动画时间 在AnimationSet 中需要设置给AnimationSet，设置给子animation是无效的。 animationSet.setDuration(1000 * 2); //动画运行完后保持动画完成的效果，在AnimationSet 中需要设置给AnimationSet，设置给子animation是无效的。 animationSet.setFillAfter(true); Animation scaleAnimation = new ScaleAnimation(0.5f, 1f, 0.5f, 1f, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 0); Animation alphaAnimation = new AlphaAnimation(0.5f, 1f); animationSet.addAnimation(scaleAnimation); animationSet.addAnimation(alphaAnimation);&#125; 1.6interpolator AccelerateDecelerateInterpolator 在动画开始与结束的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator 开始的时候向后然后向前甩 AnticipateOvershootInterpolator 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator 动画结束的时候弹起 CycleInterpolator 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator 在动画开始的地方快然后慢 LinearInterpolator 以常量速率改变 OvershootInterpolator 向前甩一定值后再回到原来位置 12345678910private void interpolator() &#123; Interpolator interpolator = new LinearInterpolator(); //动画插值器， 用于设置动画改变的速率。 animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0.1f, Animation.RELATIVE_TO_SELF, 1f); //动画时间 animation.setDuration(1000 * 2); //动画运行完后保持动画完成的效果 animation.setFillAfter(true); animation.setInterpolator(interpolator);&#125; 1.7xml中编辑动画在res下新建一个anim文件夹，添加动画文件。 参数意义和代码中的一样。1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:fromXDelta="0%p" android:toXDelta="0%p" android:fromYDelta="40%p" android:toYDelta="0%p" android:duration="80"/&gt; &lt;scale android:duration="80" android:fromXScale="0.8" android:toXScale="1.2" android:fromYScale="0.8" android:toYScale="1.2" android:pivotX="50%" android:pivotY="50%" /&gt;&lt;/set&gt; 在代码中获取动画1Animation popShowAni = AnimationUtils.loadAnimation(this, R.anim.dynamic_pop_enter); 2、帧动画1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/pulling_load1" android:duration="40"&gt;&lt;/item&gt; &lt;item android:drawable="@drawable/pulling_load2" android:duration="40"&gt;&lt;/item&gt; &lt;item android:drawable="@drawable/pulling_load3" android:duration="40"&gt;&lt;/item&gt; &lt;item android:drawable="@drawable/pulling_load4" android:duration="40"&gt;&lt;/item&gt; &lt;item android:drawable="@drawable/pulling_load5" android:duration="40"&gt;&lt;/item&gt; &lt;item android:drawable="@drawable/pulling_load6" android:duration="40"&gt;&lt;/item&gt;&lt;/animation-list&gt; 12345&lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/pulling_load" android:id="@+id/animation_view"/&gt; 12345private void frameAnimation() &#123; ImageView imageView = (ImageView) findViewById(R.id.animation_view); AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable(); drawable.start();&#125; 3 属性动画Android属性动画完全解析(上)，初识属性动画的基本用法Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之代码优化]]></title>
    <url>%2F2015%2F08%2F05%2FAndroid%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章主要是介绍了一些小细节的优化技巧，当这些小技巧综合使用起来的时候，对于整个App的性能提升还是有作用的。 虽然选择合适的算法与数据结构可以更好提高App的整体性能，但在这篇文章中不会涉及这方面，有兴趣的可以自己去了解。使用这篇文章中的小技巧作为平时写代码的习惯，这样能够提升代码的效率。 1、内存的合理分配&emsp;&emsp;Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。&emsp;&emsp;除了速度差异之外，执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。&emsp;&emsp;通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。 导致GC频繁执行有两个原因：&emsp;&emsp;•Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。&emsp;&emsp;•瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。 &emsp;&emsp;解决上面的问题有简洁直观方法，如果你在Memory Monitor里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。 &emsp;&emsp;同时我们还可以通过Allocation Tracker来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一。&emsp;&emsp;当你大致定位问题之后，接下去的问题修复也就显得相对直接简单了。例如，你需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。 2、不要持有Context的静态引用内存泄露检查工具&emsp;&emsp;其他对象中的静态成员变量引用Content会造Content不能正常的回收，造成内存泄露。静态变量的内存是不会被回收，直到应用程序退出才回收。比如下图，当Activity finish后造成Activity不能回收。12345678910111213141516public class MemoryActivity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Reference reference = new Reference(this); &#125; static class Reference &#123; private static Context context; public Reference(Context context) &#123; this.context = context; &#125; &#125;&#125; 3、在Activit销毁时应该做的事1）unregisterReceiver，注销不需要的广播接收。2）释放和关闭当前界面所有网络资源。（比如我们在使用Volley和Picasso, 在基类onDestroy中释放所有的资源）12345678@Overrideprotected void onDestroy() &#123; super.onDestroy(); // 根据tag this中断请求 RequestManager.cancelPendingRequests(this); Picasso.with(this).cancelTag(this); UploadAndDownloadManager.cancelRequest(this); // 根据tag取消上传下载&#125; 3）释放定时任务。4）释放handler资源。非静态内部类隐式地持有一个外部类对象的引用，如普通执行任务不释放资源可能不出现内存泄露，如果是handler定时执行任务一定会造成内存泄露。123456789101112131415161718192021222324252627282930public class HandlerActivity extends Activity&#123; private final static int WHAT = 1; private final static int RATE = 1000 * 10; private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case WHAT: //do something sendEmptyMessageDelayed(WHAT, RATE); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); handler.sendEmptyMessage(WHAT); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); handler.removeMessages(WHAT); &#125;&#125; 5）释放其引用Activity的资源。（如果其他对象是一个全局的对象，在Activity finish后该对象不回收也会导致Activity不能回收） 4、其他1）合理的分配任务调度。2）合理的使用线程池。(本地数据读取，网络数据读取)3）网络数据优化。 Volley解析4) 类的内直接使用成员变量访问，避免使用get、set（速度提高3-7倍）。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之布局优化]]></title>
    <url>%2F2015%2F07%2F05%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[&emsp; &emsp;Android性能优化之布局优化，主要介绍使用抽象布局标签(include, viewstub, merge)、合理编写Layout。 Android系统布局一般都是通过系统的API将XML解析为View，然后渲染视图界面上。解析XML和渲染视图需要花费时间，合理的编写布局文件将减少花费的时间。 1.介绍 使用&lt; ViewStub /&gt;标签来加载一些不常用的布局； 将可复用的组件抽取出来并通过&lt; include /&gt;标签使用； 使用&lt; merge /&gt;标签减少布局的嵌套层次； 2.ViewStub的使用&emsp; &emsp;开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费时间和内存等资源。（比如QQ在无网络状态下上方的提醒）&emsp; &emsp;使用android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。&emsp; &emsp;首先来说说ViewStub的一些特点：&emsp; &emsp;（1）ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了，可以使用成员变量保存Inflate后View。&emsp; &emsp;（2）ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。下面是Activity的布局和ViewStub的布局viewstub_layout 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;ViewStub android:id="@+id/view_stub" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout="@layout/viewstub_layout"/&gt;&lt;/RelativeLayout&gt; 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="网络错误"/&gt;&lt;/RelativeLayout&gt; 然后在MainActivity中使用和控制。 123456789101112131415161718192021222324252627public class MainActivity extends ActionBarActivity &#123; private View mNetErrorView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; private void onNetError() &#123; if (mNetErrorView != null) &#123; mNetErrorView.setVisibility(View.VISIBLE); return; &#125; //在需要的时候才inflate ViewStub mViewStub = (ViewStub) findViewById(R.id.view_stub); mNetErrorView = mViewStub.inflate(); mNetErrorView.setVisibility(View.VISIBLE); &#125; private void onNetAvailable() &#123; if (mNetErrorView != null) &#123; mNetErrorView.setVisibility(View.GONE); &#125; &#125;&#125; 在mNetErrorView显示之前hierarchy viewer查看布局关系：在mNetErrorView显示后hierarchy viewer查看布局关系： 3.include的使用&emsp; &emsp;在实际开发中，有时候很多界面的某个模块的内容一样的时候，将相同模块放在一个XML布局文件中，通过使用include引用达到代码复用和易修改的效果。（比如带返回按钮的导航栏）下面是布局文件的代码 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include layout="@layout/include_layout" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; 下面是include_layout的代码123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/app_name"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 4.merge的使用&emsp; &emsp;&lt; merge /&gt;标签的作用是合并UI布局，使用该标签能降低UI布局的嵌套层次。&emsp; &emsp;merge标签可用于两种典型情况：&emsp; &emsp;a.布局顶结点是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity内容试图的parent view就是个FrameLayout，所以可以用merge消除只剩一个。&emsp; &emsp;b.某布局作为子布局被其他布局include时，且父布局的的布局类型和子布局的类型相同（比如父布局是RelativeLayout，include的布局也是RelativeLayout），使用merge当作该布局的顶节点，这样在被引入时顶结点会自动被忽略，而将其子节点全部合并到主布局中。&emsp; &emsp;c.这种情况和b类似，使用的是ViewStub引入其他布局。 4.1 a种情景Activity ContentView的 Layout的顶节点是FrameLayout。Activity的setContentView其实是将view添加到一个FrameLayout的父布局中。1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/app_name"/&gt;&lt;/FrameLayout&gt; 使用hierarchy viewer查看布局关系：将布局改为下面的代码1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;merge xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/app_name"/&gt;&lt;/merge&gt; 使用hierarchy viewer查看布局关系： 4.2 b种情景Activity的布局文件如下：1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/app_name" android:id="@+id/tv"/&gt; &lt;include layout="@layout/include_layout" android:layout_below="@id/tv" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/RelativeLayout&gt; include_layout 的布局文件如下：123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/app_name"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/RelativeLayout&gt; 使用hierarchy viewer查看布局关系：include_layout 修改后的布局文件如下：123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;merge xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/app_name"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/merge&gt; 使用hierarchy viewer查看布局关系： 4.3 c种情景和b类似，不作概述]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下半年计划]]></title>
    <url>%2F2015%2F07%2F01%2F%E4%B8%8B%E5%8D%8A%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92.html</url>
    <content type="text"><![CDATA[由于今年7月份毕业，所以上半年毕业事情特别多，没有维护博客，下半年努力维护博客，讲学习的东西和心得分享出来。 计划 性能优化 Android重要组件的运行流程。 Android中onTouch事件分发机制。 自定义View，View的绘制流程。 感觉自己还是应用层开发，还是需要熟悉设计模式，所以准备研究设计模式。 平时多积累数据结构和算法等一些东西，毕竟梦想去BAT。 开发开源的Github客户端。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volley 源码解析]]></title>
    <url>%2F2015%2F02%2F01%2FVolley.html</url>
    <content type="text"><![CDATA[Volley 源码解析 该文章是github好友分析 本文为 Android 开源项目源码解析 中 Volley 部分项目地址：Volley，分析的版本：35ce778，Demo 地址：Volley Demo 1. 功能介绍1.1. VolleyVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。 名字由来：a burst or emission of many things or a large amount at once发布演讲时候的配图 从名字由来和配图中无数急促的火箭可以看出 Volley 的特点：特别适合数据量小，通信频繁的网络操作。（个人认为 Android 应用中绝大多数的网络操作都属于这种类型）。 1.2 Volley 的主要特点(1). 扩展性强。Volley 中大多是基于接口的设计，可配置性强。(2). 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。(3). 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，这两者的区别及优劣在4.2.1 Volley中具体介绍。(4). 提供简便的图片加载工具。 2. 总体设计2.1. 总体设计图上面是 Volley 的总体设计图，主要是通过两种Diapatch Thread不断从RequestQueue中取出请求，根据是否已缓存调用Cache或Network这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据，然后交由ResponseDelivery去做结果分发及回调处理。 2.2. Volley 中的概念简单介绍一些概念，在详细设计中会仔细介绍。Volley 的调用比较简单，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断 add Request 即可。 Volley：Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。 Request：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。 RequestQueue：表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口)，通过 start() 函数启动时会启动CacheDispatcher和NetworkDispatchers。 CacheDispatcher：一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 NetworkDispatcher：一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。 ResponseDelivery：返回结果分发接口，目前只有基于ExecutorDelivery的在入参 handler 对应线程内进行分发。 HttpStack：处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack。 Network：调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。 Cache：缓存请求结果，Volley 默认使用的是基于 sdcard 的DiskBasedCache。NetworkDispatcher得到请求结果后判断是否需要存储在 Cache，CacheDispatcher会从 Cache 中取缓存结果。 3. 流程图Volley 请求流程图 上图是 Volley 请求时的流程图，在 Volley 的发布演讲中给出，我在这里将其用中文重新画出。 4. 详细设计4.1 类关系图这是 Volley 框架的主要类关系图 图中红色圈内的部分，组成了 Volley 框架的核心，围绕 RequestQueue 类，将各个功能点以组合的方式结合在了一起。各个功能点也都是以接口或者抽象类的形式提供。红色圈外面的部分，在 Volley 源码中放在了toolbox包中，作为 Volley 为各个功能点提供的默认的具体实现。通过类图我们看出， Volley 有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。 多用组合，少用继承；针对接口编程，不针对具体实现编程。 优秀框架的设计，令人叫绝，受益良多。 4.2 核心类功能介绍4.2.1 Volley.java这个和 Volley 框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的RequestQueue对象。(1). 主要函数Volley.java 有两个重载的静态方法。123public static RequestQueue newRequestQueue(Context context)public static RequestQueue newRequestQueue(Context context, HttpStack stack) 第一个方法的实现调用了第二个方法，传 HttpStack 参数为 null。第二个方法中，如果 HttpStatck 参数为 null，则如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。1234567if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125;&#125; 得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现BasicNetwork。接着构造一个代表缓存（Cache）的基于 Disk 的具体实现DiskBasedCache。最后将网络（Network）对象和缓存（Cache）对象传入构建一个 RequestQueue，启动这个 RequestQueue，并返回。1234Network network = new BasicNetwork(stack);RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);queue.start();return queue; 我们平时大多采用Volly.newRequestQueue(context)的默认实现，构建RequestQueue。通过源码可以看出，我们可以抛开 Volley 工具类构建自定义的RequestQueue，采用自定义的HttpStatck，采用自定义的Network实现，采用自定义的Cache实现等来构建RequestQueue。优秀框架的高可拓展性的魅力来源于此啊 (2). HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。 (3). 关于 User Agent通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？如果用 Fiddler 或 Charles 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似：1Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S) 经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过1String userAgent = System.getProperty("http.agent"); 得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数1234567@Overridepublic Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123; // self-defined user agent Map&lt;String, String&gt; headerMap = new HashMap&lt;String, String&gt;(); headerMap.put("User-Agent", "android-open-project-analysis/1.0"); return headerMap;&#125; 4.2.2 Request.java代表一个网络请求的抽象类。我们通过构建一个Request类的非抽象子类(StringRequest、JsonRequest、ImageRequest或自定义)对象，并将其加入到·RequestQueue·中来完成一次网络请求操作。Volley 支持 8 种 Http 请求方式 GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCHRequest 类中包含了请求 url，请求请求方式，请求 Header，请求 Body，请求的优先级等信息。 因为是抽象类，子类必须重写的两个方法。1abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response); 子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。 1abstract protected void deliverResponse(T response); 子类重写此方法，将解析成合适类型的内容传递给它们的监听回调。 以下两个方法也经常会被重写1public byte[] getBody() 重写此方法，可以构建用于 POST、PUT、PATCH 请求方式的 Body 内容。1protected Map&lt;String, String&gt; getParams() 在上面getBody函数没有被重写情况下，此方法的返回值会被 key、value 分别编码后拼装起来转换为字节码作为 Body 内容。 4.2.3 RequestQueue.javaVolley 框架的核心类，将请求Request加入到一个运行的RequestQueue中，来完成请求操作。 (1). 主要成员变量RequestQueue 中维护了两个基于优先级的 Request 队列，缓存请求队列和网络请求队列。放在缓存请求队列中的 Request，将通过缓存获取数据；放在网络请求队列中的 Request，将通过网络获取数据。12private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); 维护了一个正在进行中，尚未完成的请求集合。1private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;(); 维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。1private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;(); (2). 启动队列创建出 RequestQueue 以后，调用 start 方法，启动队列。 1234567891011121314151617/** * Starts the dispatchers in this queue. */public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; start 方法中，开启一个缓存调度线程CacheDispatcher和 n 个网络调度线程NetworkDispatcher，这里 n 默认为4，存在优化的余地，比如可以根据 CPU 核数以及网络类型计算更合适的并发数。缓存调度线程不断的从缓存请求队列中取出 Request 去处理，网络调度线程不断的从网络请求队列中取出 Request 去处理。 (3). 加入请求1public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request); 流程图如下： (4). 请求完成1void finish(Request&lt;?&gt; request) Request 请求结束 (1). 首先从正在进行中请求集合mCurrentRequests中移除该请求。(2). 然后查找请求等待集合mWaitingRequests中是否存在等待的请求，如果存在，则将等待队列移除，并将等待队列所有的请求添加到缓存请求队列中，让缓存请求处理线程CacheDispatcher自动处理。 (5). 请求取消12public void cancelAll(RequestFilter filter)public void cancelAll(final Object tag) 取消当前请求集合中所有符合条件的请求。filter 参数表示可以按照自定义的过滤器过滤需要取消的请求。tag 表示按照Request.setTag设置好的 tag 取消请求，比如同属于某个 Activity 的。 4.2.4 CacheDispatcher.java一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 ####(1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue 缓存请求队列BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue 网络请求队列Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类 (2). 处理流程图 4.2.5 NetworkDispatcher.java一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。 (1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue 网络请求队列Network mNetwork 网络类，代表了一个可以执行请求的网络Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类，可以传递请求的结果或者错误到调用者 (2). 处理流程图 4.2.6 Cache.java缓存接口，代表了一个可以获取请求结果，存储请求结果的缓存。 (1). 主要方法：public Entry get(String key); 通过 key 获取请求的缓存实体public void put(String key, Entry entry); 存入一个请求的缓存实体public void remove(String key); 移除指定的缓存实体public void clear(); 清空缓存 (2). 代表缓存实体的内部类 Entry成员变量和方法byte[] data 请求返回的数据（Body 实体）String etag Http 响应首部中用于缓存新鲜度验证的 ETaglong serverDate Http 响应首部中的响应产生时间long ttl 缓存的过期时间long softTtl 缓存的新鲜时间Map&lt;String, String&gt; responseHeaders 响应的 Headersboolean isExpired() 判断缓存是否过期，过期缓存不能继续使用boolean refreshNeeded() 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测 4.2.7 DiskBasedCache.java继承 Cache 类，基于 Disk 的缓存实现类。 (1). 主要方法：public synchronized void initialize() 初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。public synchronized Entry get(String key) 从缓存中得到数据。先从摘要信息中得到摘要信息，然后读取缓存数据文件得到内容。public synchronized void put(String key, Entry entry) 将数据存入缓存内。先检查缓存是否会满，会则先删除缓存中部分数据，然后再新建缓存文件。private void pruneIfNeeded(int neededSpace) 检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。public synchronized void clear() 清空缓存。public synchronized void remove(String key) 删除缓存中某个元素。 (2). CacheHeader 类CacheHeader 是缓存文件摘要信息，存储在缓存文件的头部，与上面的Cache.Entry相似。 4.2.8 NoCache.java继承 Cache 类，不做任何操作的缓存实现类，可将它作为构建RequestQueue的参数以实现一个不带缓存的请求队列。 4.2.9 Network.java代表网络的接口，处理网络请求。唯一的方法，用于执行特定请求。1public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError; 4.2.10 NetworkResponse.javaNetwork中方法 performRequest 的返回值，Request的 parseNetworkResponse(…) 方法入参，是 Volley 中用于内部 Response 转换的一级。封装了网络请求响应的 StatusCode，Headers 和 Body 等。 (1). 成员变量int statusCode Http 响应状态码byte[] data Body 数据Map&lt;String, String&gt; headers 响应 Headersboolean notModified 表示是否为 304 响应long networkTimeMs 请求耗时 (2). Volley 的内部 Response 转换流程图从上到下表示从得到数据后一步步的处理，箭头旁的注释表示该步处理后的实体类。 4.2.11 BasicNetwork.java实现 Network，Volley 中默认的网络接口实现类。调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。主要实现了以下功能：(1). 利用 HttpStack 执行网络请求。(2). 如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。(3). 如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。 4.2.12 HttpStack.java用于处理 Http 请求，返回请求结果的接口。目前 Volley 中的实现有基于 HttpURLConnection 的 HurlStack 和 基于 Apache HttpClient 的 HttpClientStack。唯一方法，执行请求12public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; 执行 Request 代表的请求，第二个参数表示发起请求之前，添加额外的请求 Headers。 4.2.13 HttpClientStack.java实现 HttpStack 接口，利用 Apache 的 HttpClient 进行各种请求方式的请求。基本就是 org.apache.http 包下面相关类的常见用法，不做详解，不过与下面 HttpURLConnection 做下对比就能发现 HttpURLConnection 的 API 相对简单的多。 ####4.2.14 HurlStack.java实现 HttpStack 接口，利用 Java 的 HttpURLConnection 进行各种请求方式的请求。 4.2.15 Response.java封装了经过解析后的数据，用于传输。并且有两个内部接口 Listener 和 ErrorListener 分别可表示请求失败和成功后的回调。Response 的构造函数被私有化，而通过两个函数名更易懂的静态方法构建对象。 4.2.16 ByteArrayPool.javabyte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。主要通过一个元素长度从小到大排序的ArrayList作为 byte[] 的缓存，另有一个按使用时间先后排序的ArrayList属性用于缓存满时清理元素。1public synchronized void returnBuf(byte[] buf) 将用过的 byte[] 回收，根据 byte[] 长度按照从小到大的排序将 byte[] 插入到缓存中合适位置。1public synchronized byte[] getBuf(int len) 获取长度不小于 len 的 byte[]，遍历缓存，找出第一个长度大于传入参数len的 byte[]，并返回；如果最终没有合适的byte[]，new 一个返回。1private synchronized void trim() 当缓存的 byte 超过预先设置的大小时，按照先进先出的顺序删除最早的 byte[]。 4.2.17 PoolingByteArrayOutputStream.java继承ByteArrayOutputStream，原始 ByteArrayOutputStream 中用于接受写入 bytes 的 buf，每次空间不足时便会 new 更大容量的 byte[]，而 PoolingByteArrayOutputStream 使用了 ByteArrayPool 作为 Byte[] 缓存来减少这种操作，从而提高性能。 4.2.18 HttpHeaderParser.javaHttp header 的解析工具类，在 Volley 中主要作用是用于解析 Header 从而判断返回结果是否需要缓存，如果需要返回 Header 中相关信息。有三个方法1public static long parseDateAsEpoch(String dateStr) 解析时间，将 RFC1123 的时间格式，解析成 epoch 时间 1public static String parseCharset(Map&lt;String, String&gt; headers) 解析编码集，在 Content-Type 首部中获取编码集，如果没有找到，默认返回 ISO-8859-1 1public static Cache.Entry parseCacheHeaders(NetworkResponse response) 比较重要的方法，通过网络响应中的缓存控制 Header 和 Body 内容，构建缓存实体。如果 Header 的 Cache-Control 字段含有no-cache或no-store表示不缓存，返回 null。(1). 根据 Date 首部，获取响应生成时间(2). 根据 ETag 首部，获取响应实体标签(3). 根据 Cache－Control 和 Expires 首部，计算出缓存的过期时间，和缓存的新鲜度时间 两点需要说明下：1.没有处理Last-Modify首部，而是处理存储了Date首部，并在后续的新鲜度验证时，使用Date来构建If-Modified-Since。这与 Http 1.1 的语义有些违背。2.计算过期时间，Cache－Control 首部优先于 Expires 首部。 4.2.19 RetryPolicy.java重试策略接口有三个方法：1public int getCurrentTimeout(); 获取当前请求用时（用于Log）1public int getCurrentRetryCount(); 获取已经重试的次数（用于Log）1public void retry(VolleyError error) throws VolleyError; 确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。 4.2.20 DefaultRetryPolicy.java实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。其中mCurrentTimeoutMs变量表示已经重试次数。mBackoffMultiplier表示每次重试之前的 timeout 该乘以的因子。mCurrentTimeoutMs变量表示当前重试的 timeout 时间，会以mBackoffMultiplier作为因子累计前几次重试的 timeout。 4.2.21 ResponseDelivery.java请求结果的传输接口，用于传递请求结果或者请求错误。有三个方法：1public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response); 此方法用于传递请求结果，request 和 response 参数分别表示请求信息和返回结果信息。1public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable); 此方法用于传递请求结果，并在完成传递后执行 Runnable。1public void postError(Request&lt;?&gt; request, VolleyError error); 此方法用于传输请求错误。 4.2.22 ExecutorDelivery.java请求结果传输接口具体实现类。在 Handler 对应线程中传输缓存调度线程或者网络调度线程中产生的请求结果或请求错误，会在请求成功的情况下调用 Request.deliverResponse(…) 函数，失败时调用 Request.deliverError(…) 函数。 4.2.23 StringRequest.java继承 Request 类,代表了一个返回值为 String 的请求。将网络返回的结果数据解析为 String 类型。通过构造函数的 listener 传参，支持请求成功后的 onResponse(…) 回调。 4.2.24 JsonRequest.java抽象类，继承自 Request，代表了 body 为 JSON 的请求。提供了构建 JSON 请求参数的方法。 4.2.25 JsonObjectRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONObject 类型。 4.2.26 JsonArrayRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONArray 类型。 4.2.27 ImageRequest.java继承 Request 类，代表了一个返回值为 Image 的请求。将网络返回的结果数据解析为 Bitmap 类型。可以设置图片的最大宽度和最大高度，并计算出合适尺寸返回。每次最多解析一张图片防止 OOM。 4.2.28 ImageLoader.java封装了 ImageRequst 的方便使用的图片加载工具类。 1.可以设置自定义的ImageCache，可以是内存缓存，也可以是 Disk 缓存，将获取的图片缓存起来，重复利用，减少请求。2.可以定义图片请求过程中显示的图片和请求失败后显示的图片。3.相同请求（相同地址，相同大小）只发送一个，可以避免重复请求。// TODO 4.2.29 NetworkImageView.java利用 ImageLoader，可以加载网络图片的 ImageView有三个公开的方法：1public void setDefaultImageResId(int defaultImage) 设置默认图片，加载图片过程中显示。1public void setErrorImageResId(int errorImage) 设置错误图片，加载图片失败后显示。1public void setImageUrl(String url, ImageLoader imageLoader) 设置网络图片的 Url 和 ImageLoader，将利用这个 ImageLoader 去获取网络图片。 如果有新的图片加载请求，会把这个ImageView上旧的加载请求取消。 4.2.30 ClearCacheRequest.java用于人为清空 Http 缓存的请求。添加到 RequestQueue 后能很快执行，因为优先级很高，为Priority.IMMEDIATE。并且清空缓存的方法mCache.clear()写在了isCanceled()方法体中，能最早的得到执行。 ClearCacheRequest 的写法不敢苟同，目前看来唯一的好处就是可以将清空缓存操作也当做一个请求。而在isCanceled()中做清空操作本身就造成了歧义，不看源码没人知道在NetworkDispatcher run 方法循环的过程中，isCanceled()这个读操作竟然做了可能造成缓存被清空。只能跟源码的解释一样当做一个 Hack 操作。 4.2.31 Authenticator.java身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。 4.2.32 AndroidAuthenticator.java继承 Authenticator，基于 Android AccountManager 的认证交互实现类。 4.2.33 VolleyLog.javaVolley 的 Log 工具类。 4.2.34 VolleyError.javaVolley 中所有错误异常的父类，继承自 Exception，可通过此类设置和获取 NetworkResponse 或者请求的耗时。 4.2.35 AuthFailureError.java继承自 VolleyError，代表请求认证失败错误，如 RespondeCode 的 401 和 403。 4.2.36 NetworkError.java继承自 VolleyError，代表网络错误。 4.2.37 ParseError.java继承自 VolleyError，代表内容解析错误。 4.2.38 ServerError.java继承自 VolleyError，代表服务端错误。 4.2.39 TimeoutError.java继承自 VolleyError，代表请求超时错误。 4.2.40 NoConnectionError.java继承自NetworkError，代表无法建立连接错误。 5. 杂谈5.1 关于 Http 缓存Volley 构建了一套相对完整的符合 Http 语义的缓存机制。优点和特点(1). 根据Cache-Control和Expires首部来计算缓存的过期时间。如果两个首部都存在情况下，以Cache-Control为准。(2). 利用If-None-Match和If-Modified-Since对过期缓存或者不新鲜缓存，进行请求再验证，并处理 304 响应，更新缓存。(3). 默认的缓存实现，将缓存以文件的形式存储在 Disk，程序退出后不会丢失。 我个人认为的不足之处缓存的再验证方面，在构建If-Modified-Since请求首部时，Volley 使用了服务端响应的Date首部，没有使用Last-Modified首部。整个框架没有使用Last-Modified首部。这与 Http 语义不符。123456789101112131415private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123; // If there's no cache entry, we're done. if (entry == null) &#123; return; &#125; if (entry.etag != null) &#123; headers.put("If-None-Match", entry.etag); &#125; if (entry.serverDate &gt; 0) &#123; Date refTime = new Date(entry.serverDate); headers.put("If-Modified-Since", DateUtils.formatDate(refTime)); &#125;&#125; 服务端根据请求时通过If-Modified-Since首部传过来的时间，判断资源文件是否在If-Modified-Since时间 以后 有改动，如果有改动，返回新的请求结果。如果没有改动，返回 304 not modified。Last-Modified代表了资源文件的最后修改时间。通常使用这个首部构建If-Modified-Since的时间。Date代表了响应产生的时间，正常情况下Date时间在Last-Modified时间之后。也就是Date&gt;=Last-Modified。通过以上原理，既然Date&gt;=Last-Modified。那么我利用Date构建，也是完全正确的。 可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http 语义，采用时间比较的方式来验证If-Modified-Since，判断服务器资源文件修改时间是不是在If-Modified-Since之后。那么使用Date完全正确。可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和If-Modified-Since所传时间相等。这样使用Date就不能实现正确的再验证，因为Date的时间总不会和服务器资源文件修改时间相等。 尽管使用Date可能出现的不正确情况，归结于服务端没有正确的实现 Http 语义。但我还是希望Volley也能完全正确的实现Http语义，至少同时处理Last-Modified和Date,并且优先使用Last-Modified。 5.2 Bug(1). BasicNetwork.performRequest(…)如下代码：12345678910111213141516171819@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; …… while (true) &#123; …… try &#123; …… &#125; catch (IOException e) &#123; int statusCode = 0; NetworkResponse networkResponse = null; …… if (responseContents != null) &#123; …… &#125; else &#123; throw new NetworkError(networkResponse); &#125; &#125; &#125;&#125; BasicNetwork.performRequest(…) 最后的1throw new NetworkError(networkResponse); 应该是1throw new NetworkError(e); 更合理。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xUtils 源码解析]]></title>
    <url>%2F2015%2F01%2F25%2Fxutils.html</url>
    <content type="text"><![CDATA[xUtils 源码解析 本文为 Android 开源项目源码解析 中 xUtils 部分。项目地址：xUtils，分析的版本：192c2a886c，Demo 地址：xUtils Demo分析者：Caij 1. 功能介绍xUtils一个Android公共库框架，主要包括四个部分：View，Db, Http, Bitmap 四个模块。1.View模块主要的功能是通过注解绑定UI，资源，事件。2.Db模块是一个数据库orm框架， 简单的语句就能进行数据的操作。3.Http模块主要访问网络，支持同步，异步方式的请求，支持文件的下载。4.Bitmap模块是加载图片以及图片的处理， 支持加载本地，网络图片。而且支持图片的内存和本地缓存。 2. 详细设计2.1 View模块2.1.1 总体设计流程和关系较少， 请看下面的详细分析。 2.1.2 流程图 2.1.3 核心类功能介绍1.ViewUtils.javaView和各种事件的注入以及资源的注入。 (1)主要函数1private static void injectObject(Object handler, ViewFinder finder) 第一个参数Object handler代表的是需要注入的对象， 第二个参数是需要注入View（这个View就是handler的成员变量）所在的View或者Activity的包装对象。该方法完成了View和各种事件的注入以及资源的注入。主要的原理就是通过反射和注解。 完成Activity的setContentView。 完成View的注入。 完成资源的注入。 完成各种事件的注入。 2.ViewFinder.java(1)主要函数12public View findViewById(int id, int pid)public View findViewById(int id) 如果存在父View， 优先从父View寻找，否则从当前的View或者Activity中寻找。 3.ResLoader.java1public static Object loadRes(ResType type, Context context, int id) 获取资源文件值。支持多种资源的获取。 4.EventListenerManager.java事件的注入， 其中的设计是通过动态代理。12private final static DoubleKeyValueMap&lt;ViewInjectInfo, Class&lt;?&gt;, Object&gt; listenerCache = new DoubleKeyValueMap&lt;ViewInjectInfo, Class&lt;?&gt;, Object&gt;(); 存放监听事件接口map。 因为有些接口有多个函数， 代理会判断事件接口是否存在， 如果存在只增加代理方法就够了， 避免重新设置监听事件接口。123456public static void addEventMethod( ViewFinder finder, ViewInjectInfo info, Annotation eventAnnotation, Object handler, Method method) 代理监听事件 5.注解类2.2 Db模块2.2.1 总体设计流程和关系较少， 请看下面的详细分析 2.2.2 流程图 2.2.3 核心类功能介绍注解、反射和数据库操作知识这个模块的主要内容 1.DbUtils.java主要功能数据库的创建，数据库的增删改查。1private static HashMap&lt;String, DbUtils&gt; daoMap = new HashMap&lt;String, DbUtils&gt;(); 存放DbUtils实例对象的map，每个数据库对应一个实例， key为数据库的名称。1private synchronized static DbUtils getInstance(DaoConfig daoConfig) 采取的是单例模式，根据DaoConfig创建数据库， 中间还涉及到数据库升级。12345delete；findAll；findById；saveOrUpdate；// 当数据库没有时保存， 存在时修改。update； 增删改查。 2.DaoConfig.java123private String dbName = "xUtils.db"; // default db name数据库名称private int dbVersion = 1; //数据库版本private DbUpgradeListener dbUpgradeListener; //升级监听事件 数据库配置类。 3.FindTempCache.java在DbUtils的查询数据中1234567891011121314@SuppressWarnings("unchecked") public &lt;T&gt; List&lt;T&gt; findAll(Selector selector) throws DbException &#123; .... String sql = selector.toString(); long seq = CursorUtils.FindCacheSequence.getSeq(); findTempCache.setSeq(seq); Object obj = findTempCache.get(sql);//优先从缓存读取 if (obj != null) &#123; return (List&lt;T&gt;) obj; &#125; ... &#125; 数据库查询数据的缓存。在查询中会优先调用缓存中的数据 4.SqlInfoBuilder.javasql建表、增删改语句的组合。1234567public static SqlInfo buildCreateTableSqlInfo(DbUtils db, Class&lt;?&gt; entityType) public static SqlInfo buildDeleteSqlInfo(DbUtils db, Class&lt;?&gt; entityType, Object idValue)public static SqlInfo buildDeleteSqlInfo(DbUtils db, Class&lt;?&gt; entityType, WhereBuilder whereBuilder)public static SqlInfo buildDeleteSqlInfo(DbUtils db, Object entity)public static SqlInfo buildInsertSqlInfo(DbUtils db, Object entity)public static SqlInfo buildUpdateSqlInfo(DbUtils db, Object entity, String... updateColumnNames)public static SqlInfo buildUpdateSqlInfo(DbUtils db, Object entity, WhereBuilder whereBuilder, String... updateColumnNames) 5.SqlInfo.javasql语句和值包装对象。 6.Table.java表对象。 7.Column.java表中列对象。 8.Id.java表对应的主键对象。 9.Selector.javasql查询语句的组合。 10.WhereBuilder.javasql条件语句的组合。 2.3 Http模块2.3.1 总体设计 2.3.2 流程图 2.3.3 类图 1.HttpUtils.java支持异步同步访问网络数据， 断点下载文件。1234567//网络数据的缓存。public final static HttpCache sHttpCache = new HttpCache();//访问网络的HttpClient。private final DefaultHttpClient httpClient; private final HttpContext httpContext = new BasicHttpContext();//线程池。private final static PriorityExecutor EXECUTOR = new PriorityExecutor(DEFAULT_POOL_SIZE); 12345678910111213141516171819202122232425262728293031323334353637public HttpUtils(int connTimeout, String userAgent) &#123; //配置超时时间，UserAgent， http版本信息协议等一些信息 ..... //将配置的参数统一放到httpClient中 httpClient = new DefaultHttpClient(new ThreadSafeClientConnManager(params, schemeRegistry), params); .... //下面这个关键，设置拦截器。 默认加上gizp压缩。 通过gizp压缩后的数据传输效率高很多。 httpClient.addRequestInterceptor(new HttpRequestInterceptor() &#123; @Override public void process(org.apache.http.HttpRequest httpRequest, HttpContext httpContext) throws org.apache.http.HttpException, IOException &#123; if (!httpRequest.containsHeader(HEADER_ACCEPT_ENCODING)) &#123; httpRequest.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP); &#125; &#125; &#125;); httpClient.addResponseInterceptor(new HttpResponseInterceptor() &#123; @Override public void process(HttpResponse response, HttpContext httpContext) throws org.apache.http.HttpException, IOException &#123; final HttpEntity entity = response.getEntity(); if (entity == null) &#123; return; &#125; final Header encoding = entity.getContentEncoding(); if (encoding != null) &#123; for (HeaderElement element : encoding.getElements()) &#123; if (element.getName().equalsIgnoreCase("gzip")) &#123; //这里判断从服务器传输的数据是否需要通过gzip解压。 response.setEntity(new GZipDecompressingEntity(response.getEntity())); return; &#125; &#125; &#125; &#125; &#125;); &#125; 12345//访问网络数据private &lt;T&gt; HttpHandler&lt;T&gt; sendRequest(HttpRequest request, RequestParams params, RequestCallBack&lt;T&gt; callBack);//下载网络文件public HttpHandler&lt;File&gt; download(HttpRequest.HttpMethod method, String url, String target, RequestParams params, boolean autoResume, boolean autoRename, RequestCallBack&lt;File&gt; callback); 2.HttpRequest.java网络请求的包装类。 包括url， 访问请求方法， 参数值等。 3.RequestCallBack.java完成数据请求回调接口。 4.HttpHandler.java获取网络数据逻辑的实现。这里可以理解为系统内部AsyncTask。访问网络数据处理流程图 5.HttpCache.java网络数据的缓存，内部包含LruMemoryCache。在获取数据的时候会判断是否过期。 6.StringDownLoadHandler.javahandleEntity()将网络io流转化为String。 7.FileDownLoadHandler.javahandleEntity()将网络io流转化为File。 8.HttpException.java统一异常 2.4 Bitmap模块2.4.1 总体设计 2.4.2 流程图请查看http模块 2.4.3 类图 1.BitmapUtils.java图片的异步加载，支持本地和网络图片， 图片的压缩处理， 图片的内存缓存已经本地缓存。12private BitmapGlobalConfig globalConfig; // 线程池，缓存，和网络的配置 private BitmapDisplayConfig defaultDisplayConfig; //图片显示的配置 1234567/** * @param container 表示需要显示图片的View * @param uri 图片的uri * @param displayConfig 图片显示的配置 * @param callBack 图片加载的回调接口 */public &lt;T extends View&gt; void display(T container, String uri, BitmapDisplayConfig displayConfig, BitmapLoadCallBack&lt;T&gt; callBack) 设置图片流程图 详细流程图 2.BitmapLoadTask.java加载图片的异步任务。在doInBackground中读取图片资源 3.BitmapCache.java12private LruDiskCache mDiskLruCache; //闪存缓存private LruMemoryCache&lt;MemoryCacheKey, Bitmap&gt; mMemoryCache; //运存缓存 (1)主要函数123456//下载网络图片， 然后根据配置压缩图片， 将图片缓存。public Bitmap downloadBitmap(String uri, BitmapDisplayConfig config, final BitmapUtils.BitmapLoadTask&lt;?&gt; task)//从运存缓存中读取bitmap 在获取的时候会判断是否过期public Bitmap getBitmapFromMemCache(String uri, BitmapDisplayConfig config)//从闪存缓存中读取bitmappublic Bitmap getBitmapFromDiskCache(String uri, BitmapDisplayConfig config) 4.BitmapGlobalConfig.java配置， 包括线程池， 缓存的大小。1234567891011121314//闪存缓存的路径private String diskCachePath;//运存缓存的最大值private int memoryCacheSize = 1024 * 1024 * 4; // 4MB//闪存缓存的最大值private int diskCacheSize = 1024 * 1024 * 50; // 50M//从网络加载数据的线程池private final static PriorityExecutor BITMAP_LOAD_EXECUTOR = new PriorityExecutor(DEFAULT_POOL_SIZE);//从闪存读取数据的线程池private final static PriorityExecutor DISK_CACHE_EXECUTOR = new PriorityExecutor(2);//bitmap缓存的的时间private long defaultCacheExpiry = 1000L * 60 * 60 * 24 * 30; // 30 days//bitmap缓存private BitmapCache bitmapCache; 5.BitmapDisplayConfig.java12345678910//图片显示的大小 private BitmapSize bitmapMaxSize;//图片的动画 private Animation animation;// 图片加载过程中的显示图片 private Drawable loadingDrawable;// 图片加载失败的显示图片 private Drawable loadFailedDrawable;// 图片显示的配置色彩 private Bitmap.Config bitmapConfig = Bitmap.Config.RGB_565; 6.DefaultDownloader.java获取bitmap， 支持三种获取路径， 本地文件，资产文件， 和网络图片。 7.DefaultBitmapLoadCallBack.java图片加载完成的的回调， 默认回调将获取的bitmap值传递给view。 3. 杂谈和Volley框架相比 相同点: 1.采用了网络数据缓存机制。 2.通过handler进行线程通信 不同点： Volley的Http请求在 android 2.3 版本之前是通过HttpClient ，在之后的版本是通过URLHttpConnection。xUtils都是通过HttpClient请求网络（bitmap模块图片下载是通过URLHttpConnection）。 URLHttpConnection默认支持GZIP压缩，api操作简单。 2.Volley将Http请求数据先缓存进byte[]， 然后是分配给不同的请求转化为需要的格式。xUtils是直接转化为想要的格式。 Volley：扩展性好， 但是不能存在大数据请求，否则就OOM。xUtils：不缓存入byte[] 支持大数据的请求， 速度比Volley稍快，但扩展性就低。 4.Volley访问网络数据时直接开启固定个数线程访问网络， 在run方法中执行死循环， 阻塞等待请求队列。 xUtils是开启线程池来管理线程。 缓存失效策略， volley的所有网络数据支持从http响应头中控制是否缓存和读取缓存失效时间，每个请求可以控制是否缓存和缓存失效时间。 Xutils网络数据请求是统一自定义缓存失效时间。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014->2015]]></title>
    <url>%2F2015%2F01%2F16%2F2014%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C2015%E7%9A%84%E5%B1%95%E6%9C%9B.html</url>
    <content type="text"><![CDATA[一、2014 总结进步迅速的一年。 从学校步入社会成熟了不少；参与了实际的项目开发；深入的学习了android应用层和一些底层的知识。 成果 能够自己赚钱养活自己了。 深入的学习了java和android方面的知识。 参与了实际项目的开发。 博客和github之旅。 开源项目、 Trinea博客 、老罗的博客。 参与优秀开源项目的解析以及pr。 优秀开源项目的解析 认识了很多行业内的大牛。 阅读了一些专业技术的书籍 《深入理解android》《android内核剖析》《android性能优化》。 对j2ee、 Hadoop和ios的也有一定的了解。 不足 下半年的积极性和激情不够。 迷茫，感觉android方面感觉到达了一个不上不下的状态。 心理比较浮躁和“自大”。 分析开源项目的思想高度不够。 对j2ee、ios的只是在学习阶段， 还没有正式的项目。 抛弃了运动。 二. 2015 展望 更加深入的学习android底层的知识， linux方面的知识。 积极参加github开源项目的一些活动， 积极更新博客。 精读优秀开源作品相关源码。 主要了解网络模块的知识。 j2ee、ios希望能有提升。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask的解析]]></title>
    <url>%2F2015%2F01%2F15%2Fasynctack.html</url>
    <content type="text"><![CDATA[AsyncTask是android sdk封装的异步操作类。 隐藏了Thread、 Runnable以及其他对象， 方便开发者使用。 1. AsyncTask 的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 //第一个Integer是传递给AsyncTask的参数值的类型 //第二个Integer是onProgressUpdate参数值的类型 //第三个Integer是doInBackground返回值的类型 AsyncTask&lt;Integer, Integer, Integer&gt; asyncTask = new AsyncTask&lt;Integer, Integer, Integer&gt;() &#123; @Override protected Integer doInBackground(Integer... params) &#123; //这个方法是在子线程中执行 //这里获取传入的参数值// params[0];//表示传入的第一个参数// params[2];//表示传入的第二个参数 //进行耗时的操作 return null;//将值返回 &#125; @Override protected void onPreExecute() &#123; //这个方法是在主线程中执行 //这个是在doInBackground执行之前会调用这个方法 super.onPreExecute(); &#125; @Override protected void onPostExecute(Integer result) &#123; //这个方法是在主线程中执行 //这个是在doInBackground执行完成会调用这个方法 super.onPostExecute(result); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; //这几个方法是不过主动调用的 需要自己在doInBackground调用publishProgress(Value), 然后就会执行这个方法， 从而更新界面。 super.onProgressUpdate(values); &#125; @Override protected void onCancelled(Integer result) &#123; //当在doInBackground异常终止会调用这个方法， 这个方法默认调用onCancelled()方法 super.onCancelled(result); &#125; @Override protected void onCancelled() &#123; super.onCancelled(); &#125; &#125;; //开启任务的两种方式 //这个参数需要和上面的值类型对应.// asyncTask.execute(这里是传递给AsyncTask的参数， 这里是可变长度参数);//开始执行任务， 使用默认的线程池 // asyncTask.executeOnExecutor(exec, params); //exec 是自定义的线程池 &#125;&#125; 2. 任务执行123456789101112131415161718192021222324252627public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 执行任务，如果不配置Executor将使用默认的线程池。 3. 注意的地方，默认线程池在执行任务的时候串行执行（当一个任务执行完成后才执行下一个任务）。123456789101112131415161718192021222324private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; //单一执行就是在这里， 这里其实只是将任务添加到队列中， 而不是执行。 public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); //只有当一个任务完成才进行下一个任务 &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); //这是第一次开始的时候直接执行 &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; 4 使用的是自定义runnable，为的是能够获取返回值1234567891011121314151617181920212223242526mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); &#125;&#125;;mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occured while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125;&#125;; 5 消息传递，最后执行完成还是通过Handler进行通信。Handler源码解析1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 动态代理]]></title>
    <url>%2F2015%2F01%2F03%2Fproxy.html</url>
    <content type="text"><![CDATA[Java 动态代理 本文为 Android 开源项目源码解析 公共技术点中的 动态代理 部分 项目地址：Jave Proxy，分析的版本：openjdk 1.6，Demo 地址：Proxy Demo 分析者：Caij，校对者：Trinea，校对状态：完成 1. 相关概念1.1 代理在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。代理优点有： 隐藏委托类的实现 解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作 根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。 1.2 静态代理代理类在程序运行前已经存在的代理方式称为静态代理。通过上面解释可以知道，由开发人员编写或是编译器生成代理类的方式都属于静态代理，如下是简单的静态代理实例：12345678910111213141516171819202122232425class ClassA &#123; public void operateMethod1() &#123;&#125;; public void operateMethod2() &#123;&#125;; public void operateMethod3() &#123;&#125;;&#125;public class ClassB &#123; private ClassA a; public ClassB(ClassA a) &#123; this.a = a; &#125; public void operateMethod1() &#123; a.operateMethod1(); &#125;; public void operateMethod2() &#123; a.operateMethod2(); &#125;; // not export operateMethod3()&#125; 上面ClassA是委托类，ClassB是代理类，ClassB中的函数都是直接调用ClassA相应函数，并且隐藏了Class的operateMethod3()函数。 静态代理中代理类和委托类也常常继承同一父类或实现同一接口。 1.3 动态代理代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。 Java 提供了动态代理的实现方式，可以在运行时刻动态生成代理类。这种代理方式的一大好处是可以方便对代理类的函数做统一或特殊处理，如记录所有函数执行时间、所有函数执行前添加验证判断、对某个特殊函数进行特殊操作，而不用像静态代理方式那样需要修改每个函数。 静态代理比较简单，本文上面已简单介绍，下面重点介绍动态代理。 2. 动态代理实例实现动态代理包括三步：(1). 新建委托类；(2). 实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；(3). 通过Proxy类新建代理类对象。 下面通过实例具体介绍，假如现在我们想统计某个类所有函数的执行时间，传统的方式是在类的每个函数前打点统计，动态代理方式如下： 2.1 新建委托类12345678910111213141516171819202122232425262728293031323334353637public interface Operate &#123; public void operateMethod1(); public void operateMethod2(); public void operateMethod3();&#125;public class OperateImpl implements Operate &#123; @Override public void operateMethod1() &#123; System.out.println("Invoke operateMethod1"); sleep(110); &#125; @Override public void operateMethod2() &#123; System.out.println("Invoke operateMethod2"); sleep(120); &#125; @Override public void operateMethod3() &#123; System.out.println("Invoke operateMethod3"); sleep(130); &#125; private static void sleep(long millSeconds) &#123; try &#123; Thread.sleep(millSeconds); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Operate是一个接口，定了了一些函数，我们要统计这些函数的执行时间。OperateImpl是委托类，实现Operate接口。每个函数简单输出字符串，并等待一段时间。动态代理要求委托类必须实现了某个接口，比如这里委托类OperateImpl实现了Operate，原因会后续在微博公布。 2.2. 实现 InvocationHandler 接口123456789101112131415161718public class TimingInvocationHandler implements InvocationHandler &#123; private Object target; public TimingInvocationHandler() &#123;&#125; public TimingInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long start = System.currentTimeMillis(); Object obj = method.invoke(target, args); System.out.println(method.getName() + " cost time is:" + (System.currentTimeMillis() - start)); return obj; &#125;&#125; target属性表示委托类对象。 InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个1public Object invoke(Object proxy, Method method, Object[] args) 函数需要去实现，参数：proxy表示下面2.3 通过 Proxy.newProxyInstance() 生成的代理类对象。method表示代理对象被调用的函数。args表示代理对象被调用的函数的参数。 调用代理对象的每个函数实际最终都是调用了InvocationHandler的invoke函数。这里我们在invoke实现中添加了开始结束计时，其中还调用了委托类对象target的相应函数，这样便完成了统计执行时间的需求。invoke函数中我们也可以通过对method做一些判断，从而对某些函数特殊处理。 2.3. 通过 Proxy 类静态函数生成代理对象123456789101112131415public class Main &#123; public static void main(String[] args) &#123; // create proxy instance TimingInvocationHandler timingInvocationHandler = new TimingInvocationHandler(new OperateImpl()); Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] &#123;Operate.class&#125;, timingInvocationHandler)); // call method of proxy instance operate.operateMethod1(); System.out.println(); operate.operateMethod2(); System.out.println(); operate.operateMethod3(); &#125;&#125; 这里我们先将委托类对象new OperateImpl()作为TimingInvocationHandler构造函数入参创建timingInvocationHandler对象；然后通过Proxy.newProxyInstance(…)函数新建了一个代理对象，实际代理类就是在这时候动态生成的。我们调用该代理对象的函数就会调用到timingInvocationHandler的invoke函数(是不是有点类似静态代理)，而invoke函数实现中调用委托类对象new OperateImpl()相应的 method(是不是有点类似静态代理)。 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) loader表示类加载器interfaces表示委托类的接口，生成代理类时需要实现这些接口h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类 我们可以这样理解，如上的动态代理实现实际是双层的静态代理，开发者提供了委托类 B，程序动态生成了代理类 A。开发者还需要提供一个实现了InvocationHandler的子类 C，子类 C 连接代理类 A 和委托类 B，它是代理类 A 的委托类，委托类 B 的代理类。用户直接调用代理类 A 的对象，A 将调用转发给委托类 C，委托类 C 再将调用转发给它的委托类 B。 3. 动态代理原理实际上面最后一段已经说清了动态代理的真正原理。我们来仔细分析下 3.1 生成的动态代理类代码下面是上面示例程序运行时自动生成的动态代理类代码，如何得到这些生成的代码请见ProxyUtils，查看 class 文件可使用 jd-gui123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import com.codekk.java.test.dynamicproxy.Operate;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Operate&#123; private static Method m4; private static Method m1; private static Method m5; private static Method m0; private static Method m3; private static Method m2; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final void operateMethod1() throws &#123; try &#123; h.invoke(this, m4, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void operateMethod2() throws &#123; try &#123; h.invoke(this, m5, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void operateMethod3() throws &#123; try &#123; h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m4 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod1", new Class[0]); m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m5 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod2", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); m3 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod3", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 从中我们可以看出动态生成的代理类是以$Proxy为类名前缀，继承自Proxy，并且实现了Proxy.newProxyInstance(…)第二个参数传入的所有接口的类。如果代理类实现的接口中存在非 public 接口，则其包名为该接口的包名，否则为com.sun.proxy。其中的operateMethod1()、operateMethod2()、operateMethod3()函数都是直接交给h去处理，h在父类Proxy中定义为1protected InvocationHandler h; 即为Proxy.newProxyInstance(…)第三个参数。所以InvocationHandler的子类 C 连接代理类 A 和委托类 B，它是代理类 A 的委托类，委托类 B 的代理类。 3.2. 生成动态代理类原理以下针对 Java 1.6 源码进行分析，动态代理类是在调用Proxy.newProxyInstance(…)函数时生成的。 (1). newProxyInstance(…)函数代码如下：123456789101112131415161718192021222324252627282930public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; if (h == null) &#123; throw new NullPointerException(); &#125; /* * Look up or generate the designated proxy class. */ Class cl = getProxyClass(loader, interfaces); /* * Invoke its constructor with the designated invocation handler. */ try &#123; Constructor cons = cl.getConstructor(constructorParams); return (Object) cons.newInstance(new Object[] &#123; h &#125;); &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString()); &#125; catch (IllegalAccessException e) &#123; throw new InternalError(e.toString()); &#125; catch (InstantiationException e) &#123; throw new InternalError(e.toString()); &#125; catch (InvocationTargetException e) &#123; throw new InternalError(e.toString()); &#125;&#125; 从中可以看出它先调用getProxyClass(loader, interfaces)得到动态代理类，然后将InvocationHandler作为代理类构造函数入参新建代理类对象。 (2). getProxyClass(…)函数代码及解释如下(省略了原英文注释)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/** * 得到代理类，不存在则动态生成 * @param loader 代理类所属 ClassLoader * @param interfaces 代理类需要实现的接口 * @return */public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException&#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // 代理类类对象 Class proxyClass = null; /* collect interface names to use as key for proxy class cache */ String[] interfaceNames = new String[interfaces.length]; Set interfaceSet = new HashSet(); // for detecting duplicates /** * 入参 interfaces 检验，包含三部分 * （1）是否在入参指定的 ClassLoader 内 * （2）是否是 Interface * （3）interfaces 中是否有重复 */ for (int i = 0; i &lt; interfaces.length; i++) &#123; String interfaceName = interfaces[i].getName(); Class interfaceClass = null; try &#123; interfaceClass = Class.forName(interfaceName, false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != interfaces[i]) &#123; throw new IllegalArgumentException( interfaces[i] + " is not visible from class loader"); &#125; if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; if (interfaceSet.contains(interfaceClass)) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; interfaceSet.add(interfaceClass); interfaceNames[i] = interfaceName; &#125; // 以接口名对应的 List 作为缓存的 key Object key = Arrays.asList(interfaceNames); /* * loaderToCache 是个双层的 Map * 第一层 key 为 ClassLoader，第二层 key 为 上面的 List，value 为代理类的弱引用 */ Map cache; synchronized (loaderToCache) &#123; cache = (Map) loaderToCache.get(loader); if (cache == null) &#123; cache = new HashMap(); loaderToCache.put(loader, cache); &#125; &#125; /* * 以上面的接口名对应的 List 为 key 查找代理类，如果结果为： * (1) 弱引用，表示代理类已经在缓存中 * (2) pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成通知。 * (3) null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类 */ synchronized (cache) &#123; do &#123; Object value = cache.get(key); if (value instanceof Reference) &#123; proxyClass = (Class) ((Reference) value).get(); &#125; if (proxyClass != null) &#123; // proxy class already generated: return it return proxyClass; &#125; else if (value == pendingGenerationMarker) &#123; // proxy class being generated: wait for it try &#123; cache.wait(); &#125; catch (InterruptedException e) &#123; &#125; continue; &#125; else &#123; cache.put(key, pendingGenerationMarker); break; &#125; &#125; while (true); &#125; try &#123; String proxyPkg = null; // package to define proxy class in /* * 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面 */ for (int i = 0; i &lt; interfaces.length; i++) &#123; int flags = interfaces[i].getModifiers(); if (!Modifier.isPublic(flags)) &#123; String name = interfaces[i].getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, proxyPkg = ""; // use the unnamed package &#125; &#123; // 得到代理类的类名，jdk 1.6 版本中缺少对这个生成类已经存在的处理。 long num; synchronized (nextUniqueNumberLock) &#123; num = nextUniqueNumber++; &#125; String proxyName = proxyPkg + proxyClassNamePrefix + num; // 动态生成代理类的字节码 // 最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息写入 DataOutputStream 实现 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces); try &#123; // native 层实现，虚拟机加载代理类并返回其类对象 proxyClass = defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; throw new IllegalArgumentException(e.toString()); &#125; &#125; // add to set of all generated proxy classes, for isProxyClass proxyClasses.put(proxyClass, null); &#125; finally &#123; // 代理类生成成功则保存到缓存，否则从缓存中删除，然后通知等待的调用 synchronized (cache) &#123; if (proxyClass != null) &#123; cache.put(key, new WeakReference(proxyClass)); &#125; else &#123; cache.remove(key); &#125; cache.notifyAll(); &#125; &#125; return proxyClass;&#125; 函数主要包括三部分： 入参 interfaces 检验，包含是否在入参指定的 ClassLoader 内、是否是 Interface、interfaces 中是否有重复 以接口名对应的 List 为 key 查找代理类，如果结果为： 弱引用，表示代理类已经在缓存中； pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成返回； null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类。 如果代理类不存在调用ProxyGenerator.generateProxyClass(…)生成代理类并存入缓存，通知在等待的缓存。 函数中几个注意的地方： 代理类的缓存 key 为接口名对应的 List，接口顺序不同表示不同的 key 即不同的代理类。 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面。 代理类如果在 ClassLoader 中已经存在的情况没有做处理。 可以开启 System Properties 的sun.misc.ProxyGenerator.saveGeneratedFiles开关，保存动态类到目的地址。 Java 1.7 的实现略有不同，通过getProxyClass0(…)函数实现，实现中调用代理类的缓存，判断代理类在缓存中是否已经存在，存在直接返回，不存在则调用proxyClassCache的valueFactory属性进行动态生成，valueFactory的apply函数与上面的getProxyClass(…)函数逻辑类似。 4. 使用场景4.1 J2EE Web 开发中 Spring 的 AOP(面向切面编程) 特性作用：目标函数之间解耦。比如在 Dao 中，每次数据库操作都需要开启事务，而且在操作的时候需要关注权限。一般写法是在 Dao 的每个函数中添加相应逻辑，造成代码冗余，耦合度高。使用动态代理前伪代码如下：123456789101112131415Dao &#123; insert() &#123; 判断是否有保存的权限； 开启事务； 插入； 提交事务； &#125; delete() &#123; 判断是否有删除的权限； 开启事务； 删除； 提交事务； &#125;&#125; 使用动态代理的伪代码如下：123456789// 使用动态代理，组合每个切面的函数，而每个切面只需要关注自己的逻辑就行，达到减少代码，松耦合的效果invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; 判断是否有权限； 开启事务； Object ob = method.invoke(dao, args)； 提交事务； return ob; &#125; 4.2 基于 REST 的 Android 端网络请求框架 Retrofit作用：简化网络请求操作。一般情况下每个网络请求我们都需要调用一次HttpURLConnection或者HttpClient进行请求，或者像 Volley 一样丢进等待队列中，Retrofit 极大程度简化了这些操作，示例代码如下：12345678910public interface GitHubService &#123; @GET("/users/&#123;user&#125;/repos") List&lt;Repo&gt; listRepos(@Path("user") String user);&#125;RestAdapter restAdapter = new RestAdapter.Builder() .setEndpoint("https://api.github.com") .build();GitHubService service = restAdapter.create(GitHubService.class); 以后我们只需要直接调用1List&lt;Repo&gt; repos = service.listRepos("octocat"); 即可开始网络请求，Retrofit的原理就是基于动态代理，它同时用到了 注解 的原理，本文不做深入介绍，具体请等待 Retrofit 源码解析 完成。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler 源码解析]]></title>
    <url>%2F2014%2F12%2F26%2FHandler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[1 介绍Handler在Android中起到至关重要的作用，系统本就是通过Handler的消息来驱动的，另外一个就是在Android系统中，只有主线程才能修改UI，而且存在ANR机制，所以耗时操作需要在子线程中运行，保证程序的流畅性，因此子线程中获取的数据传递给主线程更新UI，而线程通讯就是通过Handler来处理的。 2 类介绍2.1 Handler 负责发送消息和接受消息。构造函数包含Looper，从Looper中获取消息队列，发送消息是将消息放入到消息队列中。2.2 Looper 负责初始化消息队列和开启队列租塞读取。 3 类图和流程图3.1 类图 3.2 流程图 4 源码4.1 Looper.prepare()12345678910111213141516static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); /** * 给当前线程设置一个局部变量Looper。每个线程只能设置一个Looper */ public static void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper()); &#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 主要是创建一个Looper，然后设置到线程局部变量中（ThreadLocal详细可自己了解），所以每个线程对应一个Looper，而Looper里面包含一个消息队列，再次初始化会异常。 4.2 Handler()123456789101112131415161718192021public Handler() &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = null;&#125;public Handler(Looper looper) &#123; ...&#125; 主要包含两个构造参数，如果不传Looper就会使用Looper.myLooper()通过线程局部变量获取当前线程的Looper对象，如果传递Looper，就直接使用传递进来的Looper对象。Handler最终执行方法所在的线程取决于使用哪个线程的Looper。 4.3 Looper.loop()123456789101112131415161718192021222324252627282930313233public static void loop() &#123; Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; MessageQueue queue = me.mQueue; while (true) &#123; Message msg = queue.next(); // might block 这里阻塞等待消息。 if (msg != null) &#123; if (msg.target == null) &#123; // No target is a magic identifier for the quit message. return; &#125; long wallStart = 0; long threadStart = 0; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); wallStart = SystemClock.currentTimeMicro(); threadStart = SystemClock.currentThreadTimeMicro(); &#125; msg.target.dispatchMessage(msg); msg.recycle();//这里回收消息， 实例化Message使用Message.obtain()获取回收对象。 &#125; &#125; &#125; 开启循环阻塞获取消息并分发，执行msg.target.dispatchMessage(msg)，这里的msg.targer就是Handler。 4.4 Handler.sendMessage123456789public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; //这里的消息队列就是当前线程的消息队列，是从Looper中获取的。 if (queue != null) &#123; msg.target = this; //msg.target 就是handler自己 sent = queue.enqueueMessage(msg, uptimeMillis); &#125; return sent; &#125; 就是将消息放入到消息队列中。 4.5 MessageQueue.enqueueMessage()1234567891011121314151617181920212223242526final boolean enqueueMessage(Message msg, long when) &#123; final boolean needWake; synchronized (this) &#123; msg.when = when; //Log.d("MessageQueue", "Enqueing: " + msg); Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; // new head, might need to wake up &#125; else &#123; Message prev = null; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; msg.next = prev.next; prev.next = msg; needWake = false; // still waiting on head, no need to wake up &#125; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; return true; &#125; 这里存储的方式是链表形式，主要是针对消息的执行时间排序。 5 思考为什么平时开发在主线程中没有调用Looper.prepare和Looper.loop也能直接使用Handler？可以看看ActivityThread中进程初始化的操作中已经在主线程中操作过这些。123456789101112131415161718public static final void main(String[] args) &#123; Looper.prepareMainLooper(); //这里执行的prepare if (sMainThreadHandler == null) &#123; sMainThreadHandler = new Handler(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(false); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; Looper.loop(); //这里loop &#125; &#125;]]></content>
  </entry>
</search>
